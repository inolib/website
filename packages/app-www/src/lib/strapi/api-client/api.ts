/* tslint:disable */
/* eslint-disable */
/**
 * DOCUMENTATION
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contact-email@something.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AuthChangePasswordPostRequest
 */
export interface AuthChangePasswordPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthChangePasswordPostRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof AuthChangePasswordPostRequest
     */
    'currentPassword': string;
    /**
     * 
     * @type {string}
     * @memberof AuthChangePasswordPostRequest
     */
    'passwordConfirmation': string;
}
/**
 * 
 * @export
 * @interface AuthForgotPasswordPost200Response
 */
export interface AuthForgotPasswordPost200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthForgotPasswordPost200Response
     */
    'ok'?: AuthForgotPasswordPost200ResponseOkEnum;
}

export const AuthForgotPasswordPost200ResponseOkEnum = {
    True: 'true'
} as const;

export type AuthForgotPasswordPost200ResponseOkEnum = typeof AuthForgotPasswordPost200ResponseOkEnum[keyof typeof AuthForgotPasswordPost200ResponseOkEnum];

/**
 * 
 * @export
 * @interface AuthForgotPasswordPostRequest
 */
export interface AuthForgotPasswordPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthForgotPasswordPostRequest
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface AuthLocalPostRequest
 */
export interface AuthLocalPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthLocalPostRequest
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthLocalPostRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface AuthLocalRegisterPostRequest
 */
export interface AuthLocalRegisterPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthLocalRegisterPostRequest
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthLocalRegisterPostRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthLocalRegisterPostRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface AuthResetPasswordPostRequest
 */
export interface AuthResetPasswordPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthResetPasswordPostRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResetPasswordPostRequest
     */
    'passwordConfirmation'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResetPasswordPostRequest
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface AuthSendEmailConfirmationPost200Response
 */
export interface AuthSendEmailConfirmationPost200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthSendEmailConfirmationPost200Response
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthSendEmailConfirmationPost200Response
     */
    'sent'?: AuthSendEmailConfirmationPost200ResponseSentEnum;
}

export const AuthSendEmailConfirmationPost200ResponseSentEnum = {
    True: 'true'
} as const;

export type AuthSendEmailConfirmationPost200ResponseSentEnum = typeof AuthSendEmailConfirmationPost200ResponseSentEnum[keyof typeof AuthSendEmailConfirmationPost200ResponseSentEnum];

/**
 * 
 * @export
 * @interface Author
 */
export interface Author {
    /**
     * 
     * @type {number}
     * @memberof Author
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Author
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Author
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Author
     */
    'bio'?: string;
    /**
     * 
     * @type {AuthorAvatar}
     * @memberof Author
     */
    'avatar'?: AuthorAvatar;
    /**
     * 
     * @type {string}
     * @memberof Author
     */
    'slug'?: string;
    /**
     * 
     * @type {any}
     * @memberof Author
     */
    'socials'?: any;
    /**
     * 
     * @type {string}
     * @memberof Author
     */
    'website'?: string;
    /**
     * 
     * @type {Array<AuthorFormationsInner>}
     * @memberof Author
     */
    'formations'?: Array<AuthorFormationsInner>;
    /**
     * 
     * @type {string}
     * @memberof Author
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Author
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Author
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof Author
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof Author
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof Author
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof Author
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface AuthorAvatar
 */
export interface AuthorAvatar {
    /**
     * 
     * @type {number}
     * @memberof AuthorAvatar
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatar
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatar
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatar
     */
    'alternativeText'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatar
     */
    'caption'?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthorAvatar
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthorAvatar
     */
    'height'?: number;
    /**
     * 
     * @type {any}
     * @memberof AuthorAvatar
     */
    'formats'?: any;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatar
     */
    'hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatar
     */
    'ext'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatar
     */
    'mime'?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthorAvatar
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatar
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatar
     */
    'previewUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatar
     */
    'provider'?: string;
    /**
     * 
     * @type {any}
     * @memberof AuthorAvatar
     */
    'provider_metadata'?: any;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof AuthorAvatar
     */
    'related'?: Array<AuthorAvatarRelatedInner>;
    /**
     * 
     * @type {AuthorAvatarFolder}
     * @memberof AuthorAvatar
     */
    'folder'?: AuthorAvatarFolder;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatar
     */
    'folderPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatar
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatar
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatar
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorAvatar
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorAvatar
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatar
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof AuthorAvatar
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface AuthorAvatarFolder
 */
export interface AuthorAvatarFolder {
    /**
     * 
     * @type {number}
     * @memberof AuthorAvatarFolder
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolder
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolder
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthorAvatarFolder
     */
    'pathId'?: number;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorAvatarFolder
     */
    'parent'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof AuthorAvatarFolder
     */
    'children'?: Array<AuthorAvatarRelatedInner>;
    /**
     * 
     * @type {Array<AuthorAvatarFolderFilesInner>}
     * @memberof AuthorAvatarFolder
     */
    'files'?: Array<AuthorAvatarFolderFilesInner>;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolder
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolder
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolder
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolder
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorAvatarFolder
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorAvatarFolder
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolder
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof AuthorAvatarFolder
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface AuthorAvatarFolderFilesInner
 */
export interface AuthorAvatarFolderFilesInner {
    /**
     * 
     * @type {number}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'alternativeText'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'caption'?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'height'?: number;
    /**
     * 
     * @type {any}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'formats'?: any;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'ext'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'mime'?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'previewUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'provider'?: string;
    /**
     * 
     * @type {any}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'provider_metadata'?: any;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'related'?: Array<AuthorAvatarRelatedInner>;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'folder'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'folderPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarFolderFilesInnerCreatedBy}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'createdBy'?: AuthorAvatarFolderFilesInnerCreatedBy;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof AuthorAvatarFolderFilesInner
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface AuthorAvatarFolderFilesInnerCreatedBy
 */
export interface AuthorAvatarFolderFilesInnerCreatedBy {
    /**
     * 
     * @type {number}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'firstname'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'resetPasswordToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'registrationToken'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {Array<AuthorAvatarFolderFilesInnerCreatedByRolesInner>}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'roles'?: Array<AuthorAvatarFolderFilesInnerCreatedByRolesInner>;
    /**
     * 
     * @type {boolean}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'blocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'preferedLanguage'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof AuthorAvatarFolderFilesInnerCreatedBy
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface AuthorAvatarFolderFilesInnerCreatedByRolesInner
 */
export interface AuthorAvatarFolderFilesInnerCreatedByRolesInner {
    /**
     * 
     * @type {number}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInner
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInner
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInner
     */
    'description'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInner
     */
    'users'?: Array<AuthorAvatarRelatedInner>;
    /**
     * 
     * @type {Array<AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner>}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInner
     */
    'permissions'?: Array<AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner>;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInner
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInner
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInner
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInner
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInner
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner
 */
export interface AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner {
    /**
     * 
     * @type {number}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner
     */
    'action'?: string;
    /**
     * 
     * @type {any}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner
     */
    'actionParameters'?: any;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner
     */
    'subject'?: string;
    /**
     * 
     * @type {any}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner
     */
    'properties'?: any;
    /**
     * 
     * @type {any}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner
     */
    'conditions'?: any;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner
     */
    'role'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof AuthorAvatarFolderFilesInnerCreatedByRolesInnerPermissionsInner
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface AuthorAvatarRelatedInner
 */
export interface AuthorAvatarRelatedInner {
    /**
     * 
     * @type {number}
     * @memberof AuthorAvatarRelatedInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthorAvatarRelatedInner
     */
    'documentId'?: string;
}
/**
 * 
 * @export
 * @interface AuthorFormationsInner
 */
export interface AuthorFormationsInner {
    /**
     * 
     * @type {number}
     * @memberof AuthorFormationsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInner
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInner
     */
    'titre'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInner
     */
    'description'?: string;
    /**
     * 
     * @type {Array<FormationsConceptsComponent>}
     * @memberof AuthorFormationsInner
     */
    'concepts'?: Array<FormationsConceptsComponent>;
    /**
     * 
     * @type {AuthorFormationsInnerIllustration}
     * @memberof AuthorFormationsInner
     */
    'illustration'?: AuthorFormationsInnerIllustration;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInner
     */
    'contenue'?: string;
    /**
     * 
     * @type {AuthorFormationsInnerAuthor}
     * @memberof AuthorFormationsInner
     */
    'author'?: AuthorFormationsInnerAuthor;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInner
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInner
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorFormationsInner
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorFormationsInner
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInner
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof AuthorFormationsInner
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface AuthorFormationsInnerAuthor
 */
export interface AuthorFormationsInnerAuthor {
    /**
     * 
     * @type {number}
     * @memberof AuthorFormationsInnerAuthor
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerAuthor
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerAuthor
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerAuthor
     */
    'bio'?: string;
    /**
     * 
     * @type {AuthorFormationsInnerIllustration}
     * @memberof AuthorFormationsInnerAuthor
     */
    'avatar'?: AuthorFormationsInnerIllustration;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerAuthor
     */
    'slug'?: string;
    /**
     * 
     * @type {any}
     * @memberof AuthorFormationsInnerAuthor
     */
    'socials'?: any;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerAuthor
     */
    'website'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof AuthorFormationsInnerAuthor
     */
    'formations'?: Array<AuthorAvatarRelatedInner>;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerAuthor
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerAuthor
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerAuthor
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorFormationsInnerAuthor
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorFormationsInnerAuthor
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerAuthor
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof AuthorFormationsInnerAuthor
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface AuthorFormationsInnerIllustration
 */
export interface AuthorFormationsInnerIllustration {
    /**
     * 
     * @type {number}
     * @memberof AuthorFormationsInnerIllustration
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerIllustration
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerIllustration
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerIllustration
     */
    'alternativeText'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerIllustration
     */
    'caption'?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthorFormationsInnerIllustration
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthorFormationsInnerIllustration
     */
    'height'?: number;
    /**
     * 
     * @type {any}
     * @memberof AuthorFormationsInnerIllustration
     */
    'formats'?: any;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerIllustration
     */
    'hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerIllustration
     */
    'ext'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerIllustration
     */
    'mime'?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthorFormationsInnerIllustration
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerIllustration
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerIllustration
     */
    'previewUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerIllustration
     */
    'provider'?: string;
    /**
     * 
     * @type {any}
     * @memberof AuthorFormationsInnerIllustration
     */
    'provider_metadata'?: any;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof AuthorFormationsInnerIllustration
     */
    'related'?: Array<AuthorAvatarRelatedInner>;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorFormationsInnerIllustration
     */
    'folder'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerIllustration
     */
    'folderPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerIllustration
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerIllustration
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerIllustration
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorFormationsInnerIllustration
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof AuthorFormationsInnerIllustration
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof AuthorFormationsInnerIllustration
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof AuthorFormationsInnerIllustration
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface AuthorListResponse
 */
export interface AuthorListResponse {
    /**
     * 
     * @type {Array<Author>}
     * @memberof AuthorListResponse
     */
    'data'?: Array<Author>;
    /**
     * 
     * @type {AuthorListResponseMeta}
     * @memberof AuthorListResponse
     */
    'meta'?: AuthorListResponseMeta;
}
/**
 * 
 * @export
 * @interface AuthorListResponseMeta
 */
export interface AuthorListResponseMeta {
    /**
     * 
     * @type {AuthorListResponseMetaPagination}
     * @memberof AuthorListResponseMeta
     */
    'pagination'?: AuthorListResponseMetaPagination;
}
/**
 * 
 * @export
 * @interface AuthorListResponseMetaPagination
 */
export interface AuthorListResponseMetaPagination {
    /**
     * 
     * @type {number}
     * @memberof AuthorListResponseMetaPagination
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthorListResponseMetaPagination
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthorListResponseMetaPagination
     */
    'pageCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthorListResponseMetaPagination
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface AuthorRequest
 */
export interface AuthorRequest {
    /**
     * 
     * @type {AuthorRequestData}
     * @memberof AuthorRequest
     */
    'data': AuthorRequestData;
}
/**
 * 
 * @export
 * @interface AuthorRequestData
 */
export interface AuthorRequestData {
    /**
     * 
     * @type {string}
     * @memberof AuthorRequestData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorRequestData
     */
    'bio'?: string;
    /**
     * 
     * @type {AuthorRequestDataAvatar}
     * @memberof AuthorRequestData
     */
    'avatar'?: AuthorRequestDataAvatar;
    /**
     * 
     * @type {string}
     * @memberof AuthorRequestData
     */
    'slug'?: string;
    /**
     * 
     * @type {any}
     * @memberof AuthorRequestData
     */
    'socials'?: any;
    /**
     * 
     * @type {string}
     * @memberof AuthorRequestData
     */
    'website'?: string;
    /**
     * 
     * @type {Array<AuthorRequestDataAvatar>}
     * @memberof AuthorRequestData
     */
    'formations'?: Array<AuthorRequestDataAvatar>;
    /**
     * 
     * @type {string}
     * @memberof AuthorRequestData
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorRequestDataAvatar>}
     * @memberof AuthorRequestData
     */
    'localizations'?: Array<AuthorRequestDataAvatar>;
}
/**
 * @type AuthorRequestDataAvatar
 * @export
 */
export type AuthorRequestDataAvatar = number | string;

/**
 * 
 * @export
 * @interface AuthorResponse
 */
export interface AuthorResponse {
    /**
     * 
     * @type {Author}
     * @memberof AuthorResponse
     */
    'data'?: Author;
    /**
     * 
     * @type {object}
     * @memberof AuthorResponse
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface BlogPost
 */
export interface BlogPost {
    /**
     * 
     * @type {number}
     * @memberof BlogPost
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'excerpt'?: string;
    /**
     * 
     * @type {AuthorAvatar}
     * @memberof BlogPost
     */
    'image'?: AuthorAvatar;
    /**
     * 
     * @type {BlogPostAuthor}
     * @memberof BlogPost
     */
    'author'?: BlogPostAuthor;
    /**
     * 
     * @type {Array<BlogPostCategoriesInner>}
     * @memberof BlogPost
     */
    'categories'?: Array<BlogPostCategoriesInner>;
    /**
     * 
     * @type {any}
     * @memberof BlogPost
     */
    'tags'?: any;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof BlogPost
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof BlogPost
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof BlogPost
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface BlogPostAuthor
 */
export interface BlogPostAuthor {
    /**
     * 
     * @type {number}
     * @memberof BlogPostAuthor
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthor
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthor
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthor
     */
    'bio'?: string;
    /**
     * 
     * @type {AuthorFormationsInnerIllustration}
     * @memberof BlogPostAuthor
     */
    'avatar'?: AuthorFormationsInnerIllustration;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthor
     */
    'slug'?: string;
    /**
     * 
     * @type {any}
     * @memberof BlogPostAuthor
     */
    'socials'?: any;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthor
     */
    'website'?: string;
    /**
     * 
     * @type {Array<BlogPostAuthorFormationsInner>}
     * @memberof BlogPostAuthor
     */
    'formations'?: Array<BlogPostAuthorFormationsInner>;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthor
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthor
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthor
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof BlogPostAuthor
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof BlogPostAuthor
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthor
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof BlogPostAuthor
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface BlogPostAuthorFormationsInner
 */
export interface BlogPostAuthorFormationsInner {
    /**
     * 
     * @type {number}
     * @memberof BlogPostAuthorFormationsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthorFormationsInner
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthorFormationsInner
     */
    'titre'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthorFormationsInner
     */
    'description'?: string;
    /**
     * 
     * @type {Array<FormationsConceptsComponent>}
     * @memberof BlogPostAuthorFormationsInner
     */
    'concepts'?: Array<FormationsConceptsComponent>;
    /**
     * 
     * @type {AuthorFormationsInnerIllustration}
     * @memberof BlogPostAuthorFormationsInner
     */
    'illustration'?: AuthorFormationsInnerIllustration;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthorFormationsInner
     */
    'contenue'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof BlogPostAuthorFormationsInner
     */
    'author'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthorFormationsInner
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthorFormationsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthorFormationsInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthorFormationsInner
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof BlogPostAuthorFormationsInner
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof BlogPostAuthorFormationsInner
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof BlogPostAuthorFormationsInner
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof BlogPostAuthorFormationsInner
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface BlogPostCategoriesInner
 */
export interface BlogPostCategoriesInner {
    /**
     * 
     * @type {number}
     * @memberof BlogPostCategoriesInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInner
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInner
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInner
     */
    'description'?: string;
    /**
     * 
     * @type {AuthorFormationsInnerIllustration}
     * @memberof BlogPostCategoriesInner
     */
    'cover'?: AuthorFormationsInnerIllustration;
    /**
     * 
     * @type {Array<BlogPostCategoriesInnerBlogPostsInner>}
     * @memberof BlogPostCategoriesInner
     */
    'blog_posts'?: Array<BlogPostCategoriesInnerBlogPostsInner>;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInner
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof BlogPostCategoriesInner
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof BlogPostCategoriesInner
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInner
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof BlogPostCategoriesInner
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface BlogPostCategoriesInnerBlogPostsInner
 */
export interface BlogPostCategoriesInnerBlogPostsInner {
    /**
     * 
     * @type {number}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'excerpt'?: string;
    /**
     * 
     * @type {AuthorFormationsInnerIllustration}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'image'?: AuthorFormationsInnerIllustration;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'author'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'categories'?: Array<AuthorAvatarRelatedInner>;
    /**
     * 
     * @type {any}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'tags'?: any;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof BlogPostCategoriesInnerBlogPostsInner
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface BlogPostListResponse
 */
export interface BlogPostListResponse {
    /**
     * 
     * @type {Array<BlogPost>}
     * @memberof BlogPostListResponse
     */
    'data'?: Array<BlogPost>;
    /**
     * 
     * @type {AuthorListResponseMeta}
     * @memberof BlogPostListResponse
     */
    'meta'?: AuthorListResponseMeta;
}
/**
 * 
 * @export
 * @interface BlogPostRequest
 */
export interface BlogPostRequest {
    /**
     * 
     * @type {BlogPostRequestData}
     * @memberof BlogPostRequest
     */
    'data': BlogPostRequestData;
}
/**
 * 
 * @export
 * @interface BlogPostRequestData
 */
export interface BlogPostRequestData {
    /**
     * 
     * @type {string}
     * @memberof BlogPostRequestData
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostRequestData
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostRequestData
     */
    'excerpt'?: string;
    /**
     * 
     * @type {AuthorRequestDataAvatar}
     * @memberof BlogPostRequestData
     */
    'image'?: AuthorRequestDataAvatar;
    /**
     * 
     * @type {AuthorRequestDataAvatar}
     * @memberof BlogPostRequestData
     */
    'author'?: AuthorRequestDataAvatar;
    /**
     * 
     * @type {Array<AuthorRequestDataAvatar>}
     * @memberof BlogPostRequestData
     */
    'categories'?: Array<AuthorRequestDataAvatar>;
    /**
     * 
     * @type {any}
     * @memberof BlogPostRequestData
     */
    'tags'?: any;
    /**
     * 
     * @type {string}
     * @memberof BlogPostRequestData
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogPostRequestData
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorRequestDataAvatar>}
     * @memberof BlogPostRequestData
     */
    'localizations'?: Array<AuthorRequestDataAvatar>;
}
/**
 * 
 * @export
 * @interface BlogPostResponse
 */
export interface BlogPostResponse {
    /**
     * 
     * @type {BlogPost}
     * @memberof BlogPostResponse
     */
    'data'?: BlogPost;
    /**
     * 
     * @type {object}
     * @memberof BlogPostResponse
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface BlogSetting
 */
export interface BlogSetting {
    /**
     * 
     * @type {number}
     * @memberof BlogSetting
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BlogSetting
     */
    'documentId'?: string;
    /**
     * 
     * @type {number}
     * @memberof BlogSetting
     */
    'pageSize': number;
    /**
     * 
     * @type {string}
     * @memberof BlogSetting
     */
    'heading': string;
    /**
     * 
     * @type {string}
     * @memberof BlogSetting
     */
    'description': string;
    /**
     * 
     * @type {SeoSeoMetadataComponent}
     * @memberof BlogSetting
     */
    'metadata': SeoSeoMetadataComponent;
    /**
     * 
     * @type {string}
     * @memberof BlogSetting
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogSetting
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogSetting
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof BlogSetting
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof BlogSetting
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof BlogSetting
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<BlogSettingLocalizationsInner>}
     * @memberof BlogSetting
     */
    'localizations'?: Array<BlogSettingLocalizationsInner>;
}
/**
 * 
 * @export
 * @interface BlogSettingListResponse
 */
export interface BlogSettingListResponse {
    /**
     * 
     * @type {Array<BlogSetting>}
     * @memberof BlogSettingListResponse
     */
    'data'?: Array<BlogSetting>;
    /**
     * 
     * @type {AuthorListResponseMeta}
     * @memberof BlogSettingListResponse
     */
    'meta'?: AuthorListResponseMeta;
}
/**
 * 
 * @export
 * @interface BlogSettingLocalizationsInner
 */
export interface BlogSettingLocalizationsInner {
    /**
     * 
     * @type {number}
     * @memberof BlogSettingLocalizationsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BlogSettingLocalizationsInner
     */
    'documentId'?: string;
    /**
     * 
     * @type {number}
     * @memberof BlogSettingLocalizationsInner
     */
    'pageSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof BlogSettingLocalizationsInner
     */
    'heading'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogSettingLocalizationsInner
     */
    'description'?: string;
    /**
     * 
     * @type {SeoSeoMetadataComponent}
     * @memberof BlogSettingLocalizationsInner
     */
    'metadata'?: SeoSeoMetadataComponent;
    /**
     * 
     * @type {string}
     * @memberof BlogSettingLocalizationsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogSettingLocalizationsInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogSettingLocalizationsInner
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof BlogSettingLocalizationsInner
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof BlogSettingLocalizationsInner
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof BlogSettingLocalizationsInner
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof BlogSettingLocalizationsInner
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface BlogSettingRequest
 */
export interface BlogSettingRequest {
    /**
     * 
     * @type {BlogSettingRequestData}
     * @memberof BlogSettingRequest
     */
    'data': BlogSettingRequestData;
}
/**
 * 
 * @export
 * @interface BlogSettingRequestData
 */
export interface BlogSettingRequestData {
    /**
     * 
     * @type {number}
     * @memberof BlogSettingRequestData
     */
    'pageSize': number;
    /**
     * 
     * @type {string}
     * @memberof BlogSettingRequestData
     */
    'heading': string;
    /**
     * 
     * @type {string}
     * @memberof BlogSettingRequestData
     */
    'description': string;
    /**
     * 
     * @type {SeoSeoMetadataComponent}
     * @memberof BlogSettingRequestData
     */
    'metadata': SeoSeoMetadataComponent;
    /**
     * 
     * @type {string}
     * @memberof BlogSettingRequestData
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorRequestDataAvatar>}
     * @memberof BlogSettingRequestData
     */
    'localizations'?: Array<AuthorRequestDataAvatar>;
}
/**
 * 
 * @export
 * @interface BlogSettingResponse
 */
export interface BlogSettingResponse {
    /**
     * 
     * @type {BlogSetting}
     * @memberof BlogSettingResponse
     */
    'data'?: BlogSetting;
    /**
     * 
     * @type {object}
     * @memberof BlogSettingResponse
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'description'?: string;
    /**
     * 
     * @type {AuthorAvatar}
     * @memberof Category
     */
    'cover'?: AuthorAvatar;
    /**
     * 
     * @type {Array<CategoryBlogPostsInner>}
     * @memberof Category
     */
    'blog_posts'?: Array<CategoryBlogPostsInner>;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof Category
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof Category
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof Category
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface CategoryBlogPostsInner
 */
export interface CategoryBlogPostsInner {
    /**
     * 
     * @type {number}
     * @memberof CategoryBlogPostsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInner
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInner
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInner
     */
    'excerpt'?: string;
    /**
     * 
     * @type {AuthorFormationsInnerIllustration}
     * @memberof CategoryBlogPostsInner
     */
    'image'?: AuthorFormationsInnerIllustration;
    /**
     * 
     * @type {BlogPostAuthor}
     * @memberof CategoryBlogPostsInner
     */
    'author'?: BlogPostAuthor;
    /**
     * 
     * @type {Array<CategoryBlogPostsInnerCategoriesInner>}
     * @memberof CategoryBlogPostsInner
     */
    'categories'?: Array<CategoryBlogPostsInnerCategoriesInner>;
    /**
     * 
     * @type {any}
     * @memberof CategoryBlogPostsInner
     */
    'tags'?: any;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInner
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInner
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof CategoryBlogPostsInner
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof CategoryBlogPostsInner
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInner
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof CategoryBlogPostsInner
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface CategoryBlogPostsInnerCategoriesInner
 */
export interface CategoryBlogPostsInnerCategoriesInner {
    /**
     * 
     * @type {number}
     * @memberof CategoryBlogPostsInnerCategoriesInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInnerCategoriesInner
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInnerCategoriesInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInnerCategoriesInner
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInnerCategoriesInner
     */
    'description'?: string;
    /**
     * 
     * @type {AuthorFormationsInnerIllustration}
     * @memberof CategoryBlogPostsInnerCategoriesInner
     */
    'cover'?: AuthorFormationsInnerIllustration;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof CategoryBlogPostsInnerCategoriesInner
     */
    'blog_posts'?: Array<AuthorAvatarRelatedInner>;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInnerCategoriesInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInnerCategoriesInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInnerCategoriesInner
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof CategoryBlogPostsInnerCategoriesInner
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof CategoryBlogPostsInnerCategoriesInner
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof CategoryBlogPostsInnerCategoriesInner
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof CategoryBlogPostsInnerCategoriesInner
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface CategoryListResponse
 */
export interface CategoryListResponse {
    /**
     * 
     * @type {Array<Category>}
     * @memberof CategoryListResponse
     */
    'data'?: Array<Category>;
    /**
     * 
     * @type {AuthorListResponseMeta}
     * @memberof CategoryListResponse
     */
    'meta'?: AuthorListResponseMeta;
}
/**
 * 
 * @export
 * @interface CategoryRequest
 */
export interface CategoryRequest {
    /**
     * 
     * @type {CategoryRequestData}
     * @memberof CategoryRequest
     */
    'data': CategoryRequestData;
}
/**
 * 
 * @export
 * @interface CategoryRequestData
 */
export interface CategoryRequestData {
    /**
     * 
     * @type {string}
     * @memberof CategoryRequestData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryRequestData
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryRequestData
     */
    'description'?: string;
    /**
     * 
     * @type {AuthorRequestDataAvatar}
     * @memberof CategoryRequestData
     */
    'cover'?: AuthorRequestDataAvatar;
    /**
     * 
     * @type {Array<AuthorRequestDataAvatar>}
     * @memberof CategoryRequestData
     */
    'blog_posts'?: Array<AuthorRequestDataAvatar>;
    /**
     * 
     * @type {string}
     * @memberof CategoryRequestData
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorRequestDataAvatar>}
     * @memberof CategoryRequestData
     */
    'localizations'?: Array<AuthorRequestDataAvatar>;
}
/**
 * 
 * @export
 * @interface CategoryResponse
 */
export interface CategoryResponse {
    /**
     * 
     * @type {Category}
     * @memberof CategoryResponse
     */
    'data'?: Category;
    /**
     * 
     * @type {object}
     * @memberof CategoryResponse
     */
    'meta'?: object;
}
/**
 * @type ErrorData
 * @export
 */
export type ErrorData = Array<object> | object;

/**
 * 
 * @export
 * @interface ErrorError
 */
export interface ErrorError {
    /**
     * 
     * @type {number}
     * @memberof ErrorError
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorError
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorError
     */
    'message'?: string;
    /**
     * 
     * @type {object}
     * @memberof ErrorError
     */
    'details'?: object;
}
/**
 * 
 * @export
 * @interface Formation
 */
export interface Formation {
    /**
     * 
     * @type {number}
     * @memberof Formation
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Formation
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Formation
     */
    'titre': string;
    /**
     * 
     * @type {string}
     * @memberof Formation
     */
    'description': string;
    /**
     * 
     * @type {Array<FormationsConceptsComponent>}
     * @memberof Formation
     */
    'concepts': Array<FormationsConceptsComponent>;
    /**
     * 
     * @type {AuthorFormationsInnerIllustration}
     * @memberof Formation
     */
    'illustration': AuthorFormationsInnerIllustration;
    /**
     * 
     * @type {string}
     * @memberof Formation
     */
    'contenue': string;
    /**
     * 
     * @type {BlogPostAuthor}
     * @memberof Formation
     */
    'author'?: BlogPostAuthor;
    /**
     * 
     * @type {string}
     * @memberof Formation
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof Formation
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Formation
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Formation
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof Formation
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof Formation
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof Formation
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof Formation
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface FormationListResponse
 */
export interface FormationListResponse {
    /**
     * 
     * @type {Array<Formation>}
     * @memberof FormationListResponse
     */
    'data'?: Array<Formation>;
    /**
     * 
     * @type {AuthorListResponseMeta}
     * @memberof FormationListResponse
     */
    'meta'?: AuthorListResponseMeta;
}
/**
 * 
 * @export
 * @interface FormationRequest
 */
export interface FormationRequest {
    /**
     * 
     * @type {FormationRequestData}
     * @memberof FormationRequest
     */
    'data': FormationRequestData;
}
/**
 * 
 * @export
 * @interface FormationRequestData
 */
export interface FormationRequestData {
    /**
     * 
     * @type {string}
     * @memberof FormationRequestData
     */
    'titre': string;
    /**
     * 
     * @type {string}
     * @memberof FormationRequestData
     */
    'description': string;
    /**
     * 
     * @type {Array<FormationsConceptsComponent>}
     * @memberof FormationRequestData
     */
    'concepts': Array<FormationsConceptsComponent>;
    /**
     * 
     * @type {AuthorRequestDataAvatar}
     * @memberof FormationRequestData
     */
    'illustration': AuthorRequestDataAvatar;
    /**
     * 
     * @type {string}
     * @memberof FormationRequestData
     */
    'contenue': string;
    /**
     * 
     * @type {AuthorRequestDataAvatar}
     * @memberof FormationRequestData
     */
    'author'?: AuthorRequestDataAvatar;
    /**
     * 
     * @type {string}
     * @memberof FormationRequestData
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof FormationRequestData
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorRequestDataAvatar>}
     * @memberof FormationRequestData
     */
    'localizations'?: Array<AuthorRequestDataAvatar>;
}
/**
 * 
 * @export
 * @interface FormationResponse
 */
export interface FormationResponse {
    /**
     * 
     * @type {Formation}
     * @memberof FormationResponse
     */
    'data'?: Formation;
    /**
     * 
     * @type {object}
     * @memberof FormationResponse
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface FormationSetting
 */
export interface FormationSetting {
    /**
     * 
     * @type {number}
     * @memberof FormationSetting
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FormationSetting
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormationSetting
     */
    'heading': string;
    /**
     * 
     * @type {string}
     * @memberof FormationSetting
     */
    'description': string;
    /**
     * 
     * @type {AuthorAvatar}
     * @memberof FormationSetting
     */
    'heroImage': AuthorAvatar;
    /**
     * 
     * @type {string}
     * @memberof FormationSetting
     */
    'formationTitle': string;
    /**
     * 
     * @type {string}
     * @memberof FormationSetting
     */
    'formationDescription': string;
    /**
     * 
     * @type {string}
     * @memberof FormationSetting
     */
    'pedagogicTitle': string;
    /**
     * 
     * @type {Array<FormationsPedagogicApproachComponent>}
     * @memberof FormationSetting
     */
    'pedagogicApproaches'?: Array<FormationsPedagogicApproachComponent>;
    /**
     * 
     * @type {AuthorFormationsInnerIllustration}
     * @memberof FormationSetting
     */
    'pedagogicImage': AuthorFormationsInnerIllustration;
    /**
     * 
     * @type {string}
     * @memberof FormationSetting
     */
    'whyUsTitle': string;
    /**
     * 
     * @type {string}
     * @memberof FormationSetting
     */
    'whyUsDescription': string;
    /**
     * 
     * @type {Array<FormationsWhyUsComponent>}
     * @memberof FormationSetting
     */
    'whyUs'?: Array<FormationsWhyUsComponent>;
    /**
     * 
     * @type {string}
     * @memberof FormationSetting
     */
    'certificationTitle': string;
    /**
     * 
     * @type {string}
     * @memberof FormationSetting
     */
    'certificationDescription': string;
    /**
     * 
     * @type {Array<FormationsCertificationComponent>}
     * @memberof FormationSetting
     */
    'certifications'?: Array<FormationsCertificationComponent>;
    /**
     * 
     * @type {SeoSeoMetadataComponent}
     * @memberof FormationSetting
     */
    'seo'?: SeoSeoMetadataComponent;
    /**
     * 
     * @type {string}
     * @memberof FormationSetting
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormationSetting
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormationSetting
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof FormationSetting
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof FormationSetting
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof FormationSetting
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<FormationSettingLocalizationsInner>}
     * @memberof FormationSetting
     */
    'localizations'?: Array<FormationSettingLocalizationsInner>;
}
/**
 * 
 * @export
 * @interface FormationSettingListResponse
 */
export interface FormationSettingListResponse {
    /**
     * 
     * @type {Array<FormationSetting>}
     * @memberof FormationSettingListResponse
     */
    'data'?: Array<FormationSetting>;
    /**
     * 
     * @type {AuthorListResponseMeta}
     * @memberof FormationSettingListResponse
     */
    'meta'?: AuthorListResponseMeta;
}
/**
 * 
 * @export
 * @interface FormationSettingLocalizationsInner
 */
export interface FormationSettingLocalizationsInner {
    /**
     * 
     * @type {number}
     * @memberof FormationSettingLocalizationsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingLocalizationsInner
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingLocalizationsInner
     */
    'heading'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingLocalizationsInner
     */
    'description'?: string;
    /**
     * 
     * @type {AuthorFormationsInnerIllustration}
     * @memberof FormationSettingLocalizationsInner
     */
    'heroImage'?: AuthorFormationsInnerIllustration;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingLocalizationsInner
     */
    'formationTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingLocalizationsInner
     */
    'formationDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingLocalizationsInner
     */
    'pedagogicTitle'?: string;
    /**
     * 
     * @type {Array<FormationsPedagogicApproachComponent>}
     * @memberof FormationSettingLocalizationsInner
     */
    'pedagogicApproaches'?: Array<FormationsPedagogicApproachComponent>;
    /**
     * 
     * @type {AuthorFormationsInnerIllustration}
     * @memberof FormationSettingLocalizationsInner
     */
    'pedagogicImage'?: AuthorFormationsInnerIllustration;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingLocalizationsInner
     */
    'whyUsTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingLocalizationsInner
     */
    'whyUsDescription'?: string;
    /**
     * 
     * @type {Array<FormationsWhyUsComponent>}
     * @memberof FormationSettingLocalizationsInner
     */
    'whyUs'?: Array<FormationsWhyUsComponent>;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingLocalizationsInner
     */
    'certificationTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingLocalizationsInner
     */
    'certificationDescription'?: string;
    /**
     * 
     * @type {Array<FormationsCertificationComponent>}
     * @memberof FormationSettingLocalizationsInner
     */
    'certifications'?: Array<FormationsCertificationComponent>;
    /**
     * 
     * @type {SeoSeoMetadataComponent}
     * @memberof FormationSettingLocalizationsInner
     */
    'seo'?: SeoSeoMetadataComponent;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingLocalizationsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingLocalizationsInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingLocalizationsInner
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof FormationSettingLocalizationsInner
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof FormationSettingLocalizationsInner
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingLocalizationsInner
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof FormationSettingLocalizationsInner
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface FormationSettingRequest
 */
export interface FormationSettingRequest {
    /**
     * 
     * @type {FormationSettingRequestData}
     * @memberof FormationSettingRequest
     */
    'data': FormationSettingRequestData;
}
/**
 * 
 * @export
 * @interface FormationSettingRequestData
 */
export interface FormationSettingRequestData {
    /**
     * 
     * @type {string}
     * @memberof FormationSettingRequestData
     */
    'heading': string;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingRequestData
     */
    'description': string;
    /**
     * 
     * @type {AuthorRequestDataAvatar}
     * @memberof FormationSettingRequestData
     */
    'heroImage': AuthorRequestDataAvatar;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingRequestData
     */
    'formationTitle': string;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingRequestData
     */
    'formationDescription': string;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingRequestData
     */
    'pedagogicTitle': string;
    /**
     * 
     * @type {Array<FormationsPedagogicApproachComponent>}
     * @memberof FormationSettingRequestData
     */
    'pedagogicApproaches'?: Array<FormationsPedagogicApproachComponent>;
    /**
     * 
     * @type {AuthorRequestDataAvatar}
     * @memberof FormationSettingRequestData
     */
    'pedagogicImage': AuthorRequestDataAvatar;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingRequestData
     */
    'whyUsTitle': string;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingRequestData
     */
    'whyUsDescription': string;
    /**
     * 
     * @type {Array<FormationsWhyUsComponent>}
     * @memberof FormationSettingRequestData
     */
    'whyUs'?: Array<FormationsWhyUsComponent>;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingRequestData
     */
    'certificationTitle': string;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingRequestData
     */
    'certificationDescription': string;
    /**
     * 
     * @type {Array<FormationsCertificationComponent>}
     * @memberof FormationSettingRequestData
     */
    'certifications'?: Array<FormationsCertificationComponent>;
    /**
     * 
     * @type {SeoSeoMetadataComponent}
     * @memberof FormationSettingRequestData
     */
    'seo'?: SeoSeoMetadataComponent;
    /**
     * 
     * @type {string}
     * @memberof FormationSettingRequestData
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorRequestDataAvatar>}
     * @memberof FormationSettingRequestData
     */
    'localizations'?: Array<AuthorRequestDataAvatar>;
}
/**
 * 
 * @export
 * @interface FormationSettingResponse
 */
export interface FormationSettingResponse {
    /**
     * 
     * @type {FormationSetting}
     * @memberof FormationSettingResponse
     */
    'data'?: FormationSetting;
    /**
     * 
     * @type {object}
     * @memberof FormationSettingResponse
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface FormationsCertificationComponent
 */
export interface FormationsCertificationComponent {
    /**
     * 
     * @type {number}
     * @memberof FormationsCertificationComponent
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface FormationsConceptsComponent
 */
export interface FormationsConceptsComponent {
    /**
     * 
     * @type {number}
     * @memberof FormationsConceptsComponent
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FormationsConceptsComponent
     */
    'titre'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormationsConceptsComponent
     */
    'description'?: string;
    /**
     * 
     * @type {AuthorFormationsInnerIllustration}
     * @memberof FormationsConceptsComponent
     */
    'image'?: AuthorFormationsInnerIllustration;
}
/**
 * 
 * @export
 * @interface FormationsPedagogicApproachComponent
 */
export interface FormationsPedagogicApproachComponent {
    /**
     * 
     * @type {number}
     * @memberof FormationsPedagogicApproachComponent
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FormationsPedagogicApproachComponent
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormationsPedagogicApproachComponent
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface FormationsWhyUsComponent
 */
export interface FormationsWhyUsComponent {
    /**
     * 
     * @type {number}
     * @memberof FormationsWhyUsComponent
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FormationsWhyUsComponent
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormationsWhyUsComponent
     */
    'description'?: string;
    /**
     * 
     * @type {Array<AuthorFormationsInnerIllustration>}
     * @memberof FormationsWhyUsComponent
     */
    'image'?: Array<AuthorFormationsInnerIllustration>;
}
/**
 * 
 * @export
 * @interface HomeSetting
 */
export interface HomeSetting {
    /**
     * 
     * @type {number}
     * @memberof HomeSetting
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HomeSetting
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof HomeSetting
     */
    'heading': string;
    /**
     * 
     * @type {string}
     * @memberof HomeSetting
     */
    'description': string;
    /**
     * 
     * @type {AuthorAvatar}
     * @memberof HomeSetting
     */
    'heroImage': AuthorAvatar;
    /**
     * 
     * @type {string}
     * @memberof HomeSetting
     */
    'partnersTitle': string;
    /**
     * 
     * @type {string}
     * @memberof HomeSetting
     */
    'movingText': string;
    /**
     * 
     * @type {number}
     * @memberof HomeSetting
     */
    'numberOfLastBlogsToShow': number;
    /**
     * 
     * @type {string}
     * @memberof HomeSetting
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof HomeSetting
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof HomeSetting
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof HomeSetting
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof HomeSetting
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof HomeSetting
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<HomeSettingLocalizationsInner>}
     * @memberof HomeSetting
     */
    'localizations'?: Array<HomeSettingLocalizationsInner>;
}
/**
 * 
 * @export
 * @interface HomeSettingListResponse
 */
export interface HomeSettingListResponse {
    /**
     * 
     * @type {Array<HomeSetting>}
     * @memberof HomeSettingListResponse
     */
    'data'?: Array<HomeSetting>;
    /**
     * 
     * @type {AuthorListResponseMeta}
     * @memberof HomeSettingListResponse
     */
    'meta'?: AuthorListResponseMeta;
}
/**
 * 
 * @export
 * @interface HomeSettingLocalizationsInner
 */
export interface HomeSettingLocalizationsInner {
    /**
     * 
     * @type {number}
     * @memberof HomeSettingLocalizationsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HomeSettingLocalizationsInner
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof HomeSettingLocalizationsInner
     */
    'heading'?: string;
    /**
     * 
     * @type {string}
     * @memberof HomeSettingLocalizationsInner
     */
    'description'?: string;
    /**
     * 
     * @type {AuthorFormationsInnerIllustration}
     * @memberof HomeSettingLocalizationsInner
     */
    'heroImage'?: AuthorFormationsInnerIllustration;
    /**
     * 
     * @type {string}
     * @memberof HomeSettingLocalizationsInner
     */
    'partnersTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof HomeSettingLocalizationsInner
     */
    'movingText'?: string;
    /**
     * 
     * @type {number}
     * @memberof HomeSettingLocalizationsInner
     */
    'numberOfLastBlogsToShow'?: number;
    /**
     * 
     * @type {string}
     * @memberof HomeSettingLocalizationsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof HomeSettingLocalizationsInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof HomeSettingLocalizationsInner
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof HomeSettingLocalizationsInner
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof HomeSettingLocalizationsInner
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof HomeSettingLocalizationsInner
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof HomeSettingLocalizationsInner
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface HomeSettingRequest
 */
export interface HomeSettingRequest {
    /**
     * 
     * @type {HomeSettingRequestData}
     * @memberof HomeSettingRequest
     */
    'data': HomeSettingRequestData;
}
/**
 * 
 * @export
 * @interface HomeSettingRequestData
 */
export interface HomeSettingRequestData {
    /**
     * 
     * @type {string}
     * @memberof HomeSettingRequestData
     */
    'heading': string;
    /**
     * 
     * @type {string}
     * @memberof HomeSettingRequestData
     */
    'description': string;
    /**
     * 
     * @type {AuthorRequestDataAvatar}
     * @memberof HomeSettingRequestData
     */
    'heroImage': AuthorRequestDataAvatar;
    /**
     * 
     * @type {string}
     * @memberof HomeSettingRequestData
     */
    'partnersTitle': string;
    /**
     * 
     * @type {string}
     * @memberof HomeSettingRequestData
     */
    'movingText': string;
    /**
     * 
     * @type {number}
     * @memberof HomeSettingRequestData
     */
    'numberOfLastBlogsToShow': number;
    /**
     * 
     * @type {string}
     * @memberof HomeSettingRequestData
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorRequestDataAvatar>}
     * @memberof HomeSettingRequestData
     */
    'localizations'?: Array<AuthorRequestDataAvatar>;
}
/**
 * 
 * @export
 * @interface HomeSettingResponse
 */
export interface HomeSettingResponse {
    /**
     * 
     * @type {HomeSetting}
     * @memberof HomeSettingResponse
     */
    'data'?: HomeSetting;
    /**
     * 
     * @type {object}
     * @memberof HomeSettingResponse
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {ErrorData}
     * @memberof ModelError
     */
    'data'?: ErrorData | null;
    /**
     * 
     * @type {ErrorError}
     * @memberof ModelError
     */
    'error': ErrorError;
}
/**
 * 
 * @export
 * @interface Partner
 */
export interface Partner {
    /**
     * 
     * @type {number}
     * @memberof Partner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Partner
     */
    'documentId'?: string;
    /**
     * 
     * @type {Array<AuthorAvatar>}
     * @memberof Partner
     */
    'logo': Array<AuthorAvatar>;
    /**
     * 
     * @type {number}
     * @memberof Partner
     */
    'position': number;
    /**
     * 
     * @type {string}
     * @memberof Partner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Partner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Partner
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof Partner
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof Partner
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof Partner
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<PartnerLocalizationsInner>}
     * @memberof Partner
     */
    'localizations'?: Array<PartnerLocalizationsInner>;
}
/**
 * 
 * @export
 * @interface PartnerListResponse
 */
export interface PartnerListResponse {
    /**
     * 
     * @type {Array<Partner>}
     * @memberof PartnerListResponse
     */
    'data'?: Array<Partner>;
    /**
     * 
     * @type {AuthorListResponseMeta}
     * @memberof PartnerListResponse
     */
    'meta'?: AuthorListResponseMeta;
}
/**
 * 
 * @export
 * @interface PartnerLocalizationsInner
 */
export interface PartnerLocalizationsInner {
    /**
     * 
     * @type {number}
     * @memberof PartnerLocalizationsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartnerLocalizationsInner
     */
    'documentId'?: string;
    /**
     * 
     * @type {Array<AuthorFormationsInnerIllustration>}
     * @memberof PartnerLocalizationsInner
     */
    'logo'?: Array<AuthorFormationsInnerIllustration>;
    /**
     * 
     * @type {number}
     * @memberof PartnerLocalizationsInner
     */
    'position'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartnerLocalizationsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartnerLocalizationsInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartnerLocalizationsInner
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof PartnerLocalizationsInner
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof PartnerLocalizationsInner
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof PartnerLocalizationsInner
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof PartnerLocalizationsInner
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface PartnerRequest
 */
export interface PartnerRequest {
    /**
     * 
     * @type {PartnerRequestData}
     * @memberof PartnerRequest
     */
    'data': PartnerRequestData;
}
/**
 * 
 * @export
 * @interface PartnerRequestData
 */
export interface PartnerRequestData {
    /**
     * 
     * @type {Array<AuthorRequestDataAvatar>}
     * @memberof PartnerRequestData
     */
    'logo': Array<AuthorRequestDataAvatar>;
    /**
     * 
     * @type {number}
     * @memberof PartnerRequestData
     */
    'position': number;
    /**
     * 
     * @type {string}
     * @memberof PartnerRequestData
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorRequestDataAvatar>}
     * @memberof PartnerRequestData
     */
    'localizations'?: Array<AuthorRequestDataAvatar>;
}
/**
 * 
 * @export
 * @interface PartnerResponse
 */
export interface PartnerResponse {
    /**
     * 
     * @type {Partner}
     * @memberof PartnerResponse
     */
    'data'?: Partner;
    /**
     * 
     * @type {object}
     * @memberof PartnerResponse
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface SeoSeoMetadataComponent
 */
export interface SeoSeoMetadataComponent {
    /**
     * 
     * @type {number}
     * @memberof SeoSeoMetadataComponent
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SeoSeoMetadataComponent
     */
    'metaTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof SeoSeoMetadataComponent
     */
    'metaDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof SeoSeoMetadataComponent
     */
    'canonicalURL'?: string;
    /**
     * 
     * @type {AuthorFormationsInnerIllustration}
     * @memberof SeoSeoMetadataComponent
     */
    'metaImage'?: AuthorFormationsInnerIllustration;
    /**
     * 
     * @type {string}
     * @memberof SeoSeoMetadataComponent
     */
    'metaKeywords'?: string;
}
/**
 * 
 * @export
 * @interface Testimony
 */
export interface Testimony {
    /**
     * 
     * @type {number}
     * @memberof Testimony
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Testimony
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Testimony
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof Testimony
     */
    'authorName': string;
    /**
     * 
     * @type {string}
     * @memberof Testimony
     */
    'authorDomain': string;
    /**
     * 
     * @type {number}
     * @memberof Testimony
     */
    'position': number;
    /**
     * 
     * @type {string}
     * @memberof Testimony
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Testimony
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Testimony
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarFolderFilesInnerCreatedBy}
     * @memberof Testimony
     */
    'createdBy'?: AuthorAvatarFolderFilesInnerCreatedBy;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof Testimony
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof Testimony
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<TestimonyLocalizationsInner>}
     * @memberof Testimony
     */
    'localizations'?: Array<TestimonyLocalizationsInner>;
}
/**
 * 
 * @export
 * @interface TestimonyListResponse
 */
export interface TestimonyListResponse {
    /**
     * 
     * @type {Array<Testimony>}
     * @memberof TestimonyListResponse
     */
    'data'?: Array<Testimony>;
    /**
     * 
     * @type {AuthorListResponseMeta}
     * @memberof TestimonyListResponse
     */
    'meta'?: AuthorListResponseMeta;
}
/**
 * 
 * @export
 * @interface TestimonyLocalizationsInner
 */
export interface TestimonyLocalizationsInner {
    /**
     * 
     * @type {number}
     * @memberof TestimonyLocalizationsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TestimonyLocalizationsInner
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestimonyLocalizationsInner
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestimonyLocalizationsInner
     */
    'authorName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestimonyLocalizationsInner
     */
    'authorDomain'?: string;
    /**
     * 
     * @type {number}
     * @memberof TestimonyLocalizationsInner
     */
    'position'?: number;
    /**
     * 
     * @type {string}
     * @memberof TestimonyLocalizationsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestimonyLocalizationsInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestimonyLocalizationsInner
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof TestimonyLocalizationsInner
     */
    'createdBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {AuthorAvatarRelatedInner}
     * @memberof TestimonyLocalizationsInner
     */
    'updatedBy'?: AuthorAvatarRelatedInner;
    /**
     * 
     * @type {string}
     * @memberof TestimonyLocalizationsInner
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorAvatarRelatedInner>}
     * @memberof TestimonyLocalizationsInner
     */
    'localizations'?: Array<AuthorAvatarRelatedInner>;
}
/**
 * 
 * @export
 * @interface TestimonyRequest
 */
export interface TestimonyRequest {
    /**
     * 
     * @type {TestimonyRequestData}
     * @memberof TestimonyRequest
     */
    'data': TestimonyRequestData;
}
/**
 * 
 * @export
 * @interface TestimonyRequestData
 */
export interface TestimonyRequestData {
    /**
     * 
     * @type {string}
     * @memberof TestimonyRequestData
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof TestimonyRequestData
     */
    'authorName': string;
    /**
     * 
     * @type {string}
     * @memberof TestimonyRequestData
     */
    'authorDomain': string;
    /**
     * 
     * @type {number}
     * @memberof TestimonyRequestData
     */
    'position': number;
    /**
     * 
     * @type {string}
     * @memberof TestimonyRequestData
     */
    'locale'?: string;
    /**
     * 
     * @type {Array<AuthorRequestDataAvatar>}
     * @memberof TestimonyRequestData
     */
    'localizations'?: Array<AuthorRequestDataAvatar>;
}
/**
 * 
 * @export
 * @interface TestimonyResponse
 */
export interface TestimonyResponse {
    /**
     * 
     * @type {Testimony}
     * @memberof TestimonyResponse
     */
    'data'?: Testimony;
    /**
     * 
     * @type {object}
     * @memberof TestimonyResponse
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface UploadFile
 */
export interface UploadFile {
    /**
     * 
     * @type {number}
     * @memberof UploadFile
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'alternativeText'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'caption'?: string;
    /**
     * 
     * @type {number}
     * @memberof UploadFile
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof UploadFile
     */
    'height'?: number;
    /**
     * 
     * @type {number}
     * @memberof UploadFile
     */
    'formats'?: number;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'ext'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'mime'?: string;
    /**
     * 
     * @type {number}
     * @memberof UploadFile
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'previewUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'provider'?: string;
    /**
     * 
     * @type {object}
     * @memberof UploadFile
     */
    'provider_metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFile
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UploadIdIdPostRequestFileInfo
 */
export interface UploadIdIdPostRequestFileInfo {
    /**
     * 
     * @type {string}
     * @memberof UploadIdIdPostRequestFileInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadIdIdPostRequestFileInfo
     */
    'alternativeText'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadIdIdPostRequestFileInfo
     */
    'caption'?: string;
}
/**
 * 
 * @export
 * @interface UsersPermissionsPermissionsGet200Response
 */
export interface UsersPermissionsPermissionsGet200Response {
    /**
     * 
     * @type {{ [key: string]: UsersPermissionsPermissionsTreeValue; }}
     * @memberof UsersPermissionsPermissionsGet200Response
     */
    'permissions'?: { [key: string]: UsersPermissionsPermissionsTreeValue; };
}
/**
 * every api
 * @export
 * @interface UsersPermissionsPermissionsTreeValue
 */
export interface UsersPermissionsPermissionsTreeValue {
    /**
     * every controller of the api
     * @type {{ [key: string]: { [key: string]: UsersPermissionsPermissionsTreeValueControllersValueValue; }; }}
     * @memberof UsersPermissionsPermissionsTreeValue
     */
    'controllers'?: { [key: string]: { [key: string]: UsersPermissionsPermissionsTreeValueControllersValueValue; }; };
}
/**
 * every action of every controller
 * @export
 * @interface UsersPermissionsPermissionsTreeValueControllersValueValue
 */
export interface UsersPermissionsPermissionsTreeValueControllersValueValue {
    /**
     * 
     * @type {boolean}
     * @memberof UsersPermissionsPermissionsTreeValueControllersValueValue
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsPermissionsTreeValueControllersValueValue
     */
    'policy'?: string;
}
/**
 * 
 * @export
 * @interface UsersPermissionsRole
 */
export interface UsersPermissionsRole {
    /**
     * 
     * @type {number}
     * @memberof UsersPermissionsRole
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRole
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRole
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRole
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRole
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRole
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UsersPermissionsRolesGet200Response
 */
export interface UsersPermissionsRolesGet200Response {
    /**
     * 
     * @type {Array<UsersPermissionsRolesGet200ResponseRolesInner>}
     * @memberof UsersPermissionsRolesGet200Response
     */
    'roles'?: Array<UsersPermissionsRolesGet200ResponseRolesInner>;
}
/**
 * 
 * @export
 * @interface UsersPermissionsRolesGet200ResponseRolesInner
 */
export interface UsersPermissionsRolesGet200ResponseRolesInner {
    /**
     * 
     * @type {number}
     * @memberof UsersPermissionsRolesGet200ResponseRolesInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRolesGet200ResponseRolesInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRolesGet200ResponseRolesInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRolesGet200ResponseRolesInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRolesGet200ResponseRolesInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRolesGet200ResponseRolesInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof UsersPermissionsRolesGet200ResponseRolesInner
     */
    'nb_users'?: number;
}
/**
 * 
 * @export
 * @interface UsersPermissionsRolesIdGet200Response
 */
export interface UsersPermissionsRolesIdGet200Response {
    /**
     * 
     * @type {UsersPermissionsRole}
     * @memberof UsersPermissionsRolesIdGet200Response
     */
    'role'?: UsersPermissionsRole;
}
/**
 * 
 * @export
 * @interface UsersPermissionsRolesPostRequest
 */
export interface UsersPermissionsRolesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRolesPostRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRolesPostRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsRolesPostRequest
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: UsersPermissionsPermissionsTreeValue; }}
     * @memberof UsersPermissionsRolesPostRequest
     */
    'permissions'?: { [key: string]: UsersPermissionsPermissionsTreeValue; };
}
/**
 * 
 * @export
 * @interface UsersPermissionsUser
 */
export interface UsersPermissionsUser {
    /**
     * 
     * @type {number}
     * @memberof UsersPermissionsUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsUser
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsUser
     */
    'provider'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UsersPermissionsUser
     */
    'confirmed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UsersPermissionsUser
     */
    'blocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsUser
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsUser
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UsersPermissionsUserRegistration
 */
export interface UsersPermissionsUserRegistration {
    /**
     * 
     * @type {string}
     * @memberof UsersPermissionsUserRegistration
     */
    'jwt'?: string;
    /**
     * 
     * @type {UsersPermissionsUser}
     * @memberof UsersPermissionsUserRegistration
     */
    'user'?: UsersPermissionsUser;
}
/**
 * 
 * @export
 * @interface UsersPost201Response
 */
export interface UsersPost201Response {
    /**
     * 
     * @type {number}
     * @memberof UsersPost201Response
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UsersPost201Response
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPost201Response
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPost201Response
     */
    'provider'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UsersPost201Response
     */
    'confirmed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UsersPost201Response
     */
    'blocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UsersPost201Response
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersPost201Response
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {UsersPermissionsRole}
     * @memberof UsersPost201Response
     */
    'role'?: UsersPermissionsRole;
}
/**
 * 
 * @export
 * @interface UsersPostRequest
 */
export interface UsersPostRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'password': string;
}

/**
 * AuthorApi - axios parameter creator
 * @export
 */
export const AuthorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthorsId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAuthorsId', 'id', id)
            const localVarPath = `/authors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthors: async (sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (paginationWithCount !== undefined) {
                localVarQueryParameter['pagination[withCount]'] = paginationWithCount;
            }

            if (paginationPage !== undefined) {
                localVarQueryParameter['pagination[page]'] = paginationPage;
            }

            if (paginationPageSize !== undefined) {
                localVarQueryParameter['pagination[pageSize]'] = paginationPageSize;
            }

            if (paginationStart !== undefined) {
                localVarQueryParameter['pagination[start]'] = paginationStart;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination[limit]'] = paginationLimit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (populate !== undefined) {
                localVarQueryParameter['populate'] = populate;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorsId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAuthorsId', 'id', id)
            const localVarPath = `/authors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthorRequest} authorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthors: async (authorRequest: AuthorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorRequest' is not null or undefined
            assertParamExists('postAuthors', 'authorRequest', authorRequest)
            const localVarPath = `/authors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {AuthorRequest} authorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthorsId: async (id: number, authorRequest: AuthorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putAuthorsId', 'id', id)
            // verify required parameter 'authorRequest' is not null or undefined
            assertParamExists('putAuthorsId', 'authorRequest', authorRequest)
            const localVarPath = `/authors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorApi - functional programming interface
 * @export
 */
export const AuthorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthorsId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAuthorsId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorApi.deleteAuthorsId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthors(sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthors(sort, paginationWithCount, paginationPage, paginationPageSize, paginationStart, paginationLimit, fields, populate, filters, locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorApi.getAuthors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthorsId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthorsId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorApi.getAuthorsId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthorRequest} authorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthors(authorRequest: AuthorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthors(authorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorApi.postAuthors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {AuthorRequest} authorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAuthorsId(id: number, authorRequest: AuthorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAuthorsId(id, authorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorApi.putAuthorsId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthorApi - factory interface
 * @export
 */
export const AuthorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthorApiDeleteAuthorsIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthorsId(requestParameters: AuthorApiDeleteAuthorsIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteAuthorsId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthorApiGetAuthorsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthors(requestParameters: AuthorApiGetAuthorsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AuthorListResponse> {
            return localVarFp.getAuthors(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthorApiGetAuthorsIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorsId(requestParameters: AuthorApiGetAuthorsIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthorResponse> {
            return localVarFp.getAuthorsId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthorApiPostAuthorsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthors(requestParameters: AuthorApiPostAuthorsRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthorResponse> {
            return localVarFp.postAuthors(requestParameters.authorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthorApiPutAuthorsIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthorsId(requestParameters: AuthorApiPutAuthorsIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthorResponse> {
            return localVarFp.putAuthorsId(requestParameters.id, requestParameters.authorRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteAuthorsId operation in AuthorApi.
 * @export
 * @interface AuthorApiDeleteAuthorsIdRequest
 */
export interface AuthorApiDeleteAuthorsIdRequest {
    /**
     * 
     * @type {number}
     * @memberof AuthorApiDeleteAuthorsId
     */
    readonly id: number
}

/**
 * Request parameters for getAuthors operation in AuthorApi.
 * @export
 * @interface AuthorApiGetAuthorsRequest
 */
export interface AuthorApiGetAuthorsRequest {
    /**
     * Sort by attributes ascending (asc) or descending (desc)
     * @type {string}
     * @memberof AuthorApiGetAuthors
     */
    readonly sort?: string

    /**
     * Return page/pageSize (default: true)
     * @type {boolean}
     * @memberof AuthorApiGetAuthors
     */
    readonly paginationWithCount?: boolean

    /**
     * Page number (default: 0)
     * @type {number}
     * @memberof AuthorApiGetAuthors
     */
    readonly paginationPage?: number

    /**
     * Page size (default: 25)
     * @type {number}
     * @memberof AuthorApiGetAuthors
     */
    readonly paginationPageSize?: number

    /**
     * Offset value (default: 0)
     * @type {number}
     * @memberof AuthorApiGetAuthors
     */
    readonly paginationStart?: number

    /**
     * Number of entities to return (default: 25)
     * @type {number}
     * @memberof AuthorApiGetAuthors
     */
    readonly paginationLimit?: number

    /**
     * Fields to return (ex: title,author)
     * @type {string}
     * @memberof AuthorApiGetAuthors
     */
    readonly fields?: string

    /**
     * Relations to return
     * @type {string}
     * @memberof AuthorApiGetAuthors
     */
    readonly populate?: string

    /**
     * Filters to apply
     * @type {{ [key: string]: any; }}
     * @memberof AuthorApiGetAuthors
     */
    readonly filters?: { [key: string]: any; }

    /**
     * Locale to apply
     * @type {string}
     * @memberof AuthorApiGetAuthors
     */
    readonly locale?: string
}

/**
 * Request parameters for getAuthorsId operation in AuthorApi.
 * @export
 * @interface AuthorApiGetAuthorsIdRequest
 */
export interface AuthorApiGetAuthorsIdRequest {
    /**
     * 
     * @type {number}
     * @memberof AuthorApiGetAuthorsId
     */
    readonly id: number
}

/**
 * Request parameters for postAuthors operation in AuthorApi.
 * @export
 * @interface AuthorApiPostAuthorsRequest
 */
export interface AuthorApiPostAuthorsRequest {
    /**
     * 
     * @type {AuthorRequest}
     * @memberof AuthorApiPostAuthors
     */
    readonly authorRequest: AuthorRequest
}

/**
 * Request parameters for putAuthorsId operation in AuthorApi.
 * @export
 * @interface AuthorApiPutAuthorsIdRequest
 */
export interface AuthorApiPutAuthorsIdRequest {
    /**
     * 
     * @type {number}
     * @memberof AuthorApiPutAuthorsId
     */
    readonly id: number

    /**
     * 
     * @type {AuthorRequest}
     * @memberof AuthorApiPutAuthorsId
     */
    readonly authorRequest: AuthorRequest
}

/**
 * AuthorApi - object-oriented interface
 * @export
 * @class AuthorApi
 * @extends {BaseAPI}
 */
export class AuthorApi extends BaseAPI {
    /**
     * 
     * @param {AuthorApiDeleteAuthorsIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorApi
     */
    public deleteAuthorsId(requestParameters: AuthorApiDeleteAuthorsIdRequest, options?: RawAxiosRequestConfig) {
        return AuthorApiFp(this.configuration).deleteAuthorsId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthorApiGetAuthorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorApi
     */
    public getAuthors(requestParameters: AuthorApiGetAuthorsRequest = {}, options?: RawAxiosRequestConfig) {
        return AuthorApiFp(this.configuration).getAuthors(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthorApiGetAuthorsIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorApi
     */
    public getAuthorsId(requestParameters: AuthorApiGetAuthorsIdRequest, options?: RawAxiosRequestConfig) {
        return AuthorApiFp(this.configuration).getAuthorsId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthorApiPostAuthorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorApi
     */
    public postAuthors(requestParameters: AuthorApiPostAuthorsRequest, options?: RawAxiosRequestConfig) {
        return AuthorApiFp(this.configuration).postAuthors(requestParameters.authorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthorApiPutAuthorsIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorApi
     */
    public putAuthorsId(requestParameters: AuthorApiPutAuthorsIdRequest, options?: RawAxiosRequestConfig) {
        return AuthorApiFp(this.configuration).putAuthorsId(requestParameters.id, requestParameters.authorRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BlogPostApi - axios parameter creator
 * @export
 */
export const BlogPostApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogPostsId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBlogPostsId', 'id', id)
            const localVarPath = `/blog-posts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogPosts: async (sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/blog-posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (paginationWithCount !== undefined) {
                localVarQueryParameter['pagination[withCount]'] = paginationWithCount;
            }

            if (paginationPage !== undefined) {
                localVarQueryParameter['pagination[page]'] = paginationPage;
            }

            if (paginationPageSize !== undefined) {
                localVarQueryParameter['pagination[pageSize]'] = paginationPageSize;
            }

            if (paginationStart !== undefined) {
                localVarQueryParameter['pagination[start]'] = paginationStart;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination[limit]'] = paginationLimit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (populate !== undefined) {
                localVarQueryParameter['populate'] = populate;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogPostsId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBlogPostsId', 'id', id)
            const localVarPath = `/blog-posts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BlogPostRequest} blogPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogPosts: async (blogPostRequest: BlogPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogPostRequest' is not null or undefined
            assertParamExists('postBlogPosts', 'blogPostRequest', blogPostRequest)
            const localVarPath = `/blog-posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blogPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {BlogPostRequest} blogPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBlogPostsId: async (id: number, blogPostRequest: BlogPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putBlogPostsId', 'id', id)
            // verify required parameter 'blogPostRequest' is not null or undefined
            assertParamExists('putBlogPostsId', 'blogPostRequest', blogPostRequest)
            const localVarPath = `/blog-posts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blogPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlogPostApi - functional programming interface
 * @export
 */
export const BlogPostApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlogPostApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBlogPostsId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBlogPostsId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogPostApi.deleteBlogPostsId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlogPosts(sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogPostListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlogPosts(sort, paginationWithCount, paginationPage, paginationPageSize, paginationStart, paginationLimit, fields, populate, filters, locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogPostApi.getBlogPosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlogPostsId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlogPostsId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogPostApi.getBlogPostsId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {BlogPostRequest} blogPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBlogPosts(blogPostRequest: BlogPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postBlogPosts(blogPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogPostApi.postBlogPosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {BlogPostRequest} blogPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBlogPostsId(id: number, blogPostRequest: BlogPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putBlogPostsId(id, blogPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogPostApi.putBlogPostsId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BlogPostApi - factory interface
 * @export
 */
export const BlogPostApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlogPostApiFp(configuration)
    return {
        /**
         * 
         * @param {BlogPostApiDeleteBlogPostsIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogPostsId(requestParameters: BlogPostApiDeleteBlogPostsIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteBlogPostsId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BlogPostApiGetBlogPostsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogPosts(requestParameters: BlogPostApiGetBlogPostsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<BlogPostListResponse> {
            return localVarFp.getBlogPosts(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BlogPostApiGetBlogPostsIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogPostsId(requestParameters: BlogPostApiGetBlogPostsIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<BlogPostResponse> {
            return localVarFp.getBlogPostsId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BlogPostApiPostBlogPostsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogPosts(requestParameters: BlogPostApiPostBlogPostsRequest, options?: RawAxiosRequestConfig): AxiosPromise<BlogPostResponse> {
            return localVarFp.postBlogPosts(requestParameters.blogPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BlogPostApiPutBlogPostsIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBlogPostsId(requestParameters: BlogPostApiPutBlogPostsIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<BlogPostResponse> {
            return localVarFp.putBlogPostsId(requestParameters.id, requestParameters.blogPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteBlogPostsId operation in BlogPostApi.
 * @export
 * @interface BlogPostApiDeleteBlogPostsIdRequest
 */
export interface BlogPostApiDeleteBlogPostsIdRequest {
    /**
     * 
     * @type {number}
     * @memberof BlogPostApiDeleteBlogPostsId
     */
    readonly id: number
}

/**
 * Request parameters for getBlogPosts operation in BlogPostApi.
 * @export
 * @interface BlogPostApiGetBlogPostsRequest
 */
export interface BlogPostApiGetBlogPostsRequest {
    /**
     * Sort by attributes ascending (asc) or descending (desc)
     * @type {string}
     * @memberof BlogPostApiGetBlogPosts
     */
    readonly sort?: string

    /**
     * Return page/pageSize (default: true)
     * @type {boolean}
     * @memberof BlogPostApiGetBlogPosts
     */
    readonly paginationWithCount?: boolean

    /**
     * Page number (default: 0)
     * @type {number}
     * @memberof BlogPostApiGetBlogPosts
     */
    readonly paginationPage?: number

    /**
     * Page size (default: 25)
     * @type {number}
     * @memberof BlogPostApiGetBlogPosts
     */
    readonly paginationPageSize?: number

    /**
     * Offset value (default: 0)
     * @type {number}
     * @memberof BlogPostApiGetBlogPosts
     */
    readonly paginationStart?: number

    /**
     * Number of entities to return (default: 25)
     * @type {number}
     * @memberof BlogPostApiGetBlogPosts
     */
    readonly paginationLimit?: number

    /**
     * Fields to return (ex: title,author)
     * @type {string}
     * @memberof BlogPostApiGetBlogPosts
     */
    readonly fields?: string

    /**
     * Relations to return
     * @type {string}
     * @memberof BlogPostApiGetBlogPosts
     */
    readonly populate?: string

    /**
     * Filters to apply
     * @type {{ [key: string]: any; }}
     * @memberof BlogPostApiGetBlogPosts
     */
    readonly filters?: { [key: string]: any; }

    /**
     * Locale to apply
     * @type {string}
     * @memberof BlogPostApiGetBlogPosts
     */
    readonly locale?: string
}

/**
 * Request parameters for getBlogPostsId operation in BlogPostApi.
 * @export
 * @interface BlogPostApiGetBlogPostsIdRequest
 */
export interface BlogPostApiGetBlogPostsIdRequest {
    /**
     * 
     * @type {number}
     * @memberof BlogPostApiGetBlogPostsId
     */
    readonly id: number
}

/**
 * Request parameters for postBlogPosts operation in BlogPostApi.
 * @export
 * @interface BlogPostApiPostBlogPostsRequest
 */
export interface BlogPostApiPostBlogPostsRequest {
    /**
     * 
     * @type {BlogPostRequest}
     * @memberof BlogPostApiPostBlogPosts
     */
    readonly blogPostRequest: BlogPostRequest
}

/**
 * Request parameters for putBlogPostsId operation in BlogPostApi.
 * @export
 * @interface BlogPostApiPutBlogPostsIdRequest
 */
export interface BlogPostApiPutBlogPostsIdRequest {
    /**
     * 
     * @type {number}
     * @memberof BlogPostApiPutBlogPostsId
     */
    readonly id: number

    /**
     * 
     * @type {BlogPostRequest}
     * @memberof BlogPostApiPutBlogPostsId
     */
    readonly blogPostRequest: BlogPostRequest
}

/**
 * BlogPostApi - object-oriented interface
 * @export
 * @class BlogPostApi
 * @extends {BaseAPI}
 */
export class BlogPostApi extends BaseAPI {
    /**
     * 
     * @param {BlogPostApiDeleteBlogPostsIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogPostApi
     */
    public deleteBlogPostsId(requestParameters: BlogPostApiDeleteBlogPostsIdRequest, options?: RawAxiosRequestConfig) {
        return BlogPostApiFp(this.configuration).deleteBlogPostsId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BlogPostApiGetBlogPostsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogPostApi
     */
    public getBlogPosts(requestParameters: BlogPostApiGetBlogPostsRequest = {}, options?: RawAxiosRequestConfig) {
        return BlogPostApiFp(this.configuration).getBlogPosts(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BlogPostApiGetBlogPostsIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogPostApi
     */
    public getBlogPostsId(requestParameters: BlogPostApiGetBlogPostsIdRequest, options?: RawAxiosRequestConfig) {
        return BlogPostApiFp(this.configuration).getBlogPostsId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BlogPostApiPostBlogPostsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogPostApi
     */
    public postBlogPosts(requestParameters: BlogPostApiPostBlogPostsRequest, options?: RawAxiosRequestConfig) {
        return BlogPostApiFp(this.configuration).postBlogPosts(requestParameters.blogPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BlogPostApiPutBlogPostsIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogPostApi
     */
    public putBlogPostsId(requestParameters: BlogPostApiPutBlogPostsIdRequest, options?: RawAxiosRequestConfig) {
        return BlogPostApiFp(this.configuration).putBlogPostsId(requestParameters.id, requestParameters.blogPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BlogSettingApi - axios parameter creator
 * @export
 */
export const BlogSettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogSetting: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/blog-setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogSetting: async (sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/blog-setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (paginationWithCount !== undefined) {
                localVarQueryParameter['pagination[withCount]'] = paginationWithCount;
            }

            if (paginationPage !== undefined) {
                localVarQueryParameter['pagination[page]'] = paginationPage;
            }

            if (paginationPageSize !== undefined) {
                localVarQueryParameter['pagination[pageSize]'] = paginationPageSize;
            }

            if (paginationStart !== undefined) {
                localVarQueryParameter['pagination[start]'] = paginationStart;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination[limit]'] = paginationLimit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (populate !== undefined) {
                localVarQueryParameter['populate'] = populate;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BlogSettingRequest} blogSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBlogSetting: async (blogSettingRequest: BlogSettingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogSettingRequest' is not null or undefined
            assertParamExists('putBlogSetting', 'blogSettingRequest', blogSettingRequest)
            const localVarPath = `/blog-setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blogSettingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlogSettingApi - functional programming interface
 * @export
 */
export const BlogSettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlogSettingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBlogSetting(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBlogSetting(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogSettingApi.deleteBlogSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlogSetting(sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogSettingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlogSetting(sort, paginationWithCount, paginationPage, paginationPageSize, paginationStart, paginationLimit, fields, populate, filters, locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogSettingApi.getBlogSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {BlogSettingRequest} blogSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBlogSetting(blogSettingRequest: BlogSettingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogSettingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putBlogSetting(blogSettingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogSettingApi.putBlogSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BlogSettingApi - factory interface
 * @export
 */
export const BlogSettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlogSettingApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogSetting(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteBlogSetting(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BlogSettingApiGetBlogSettingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogSetting(requestParameters: BlogSettingApiGetBlogSettingRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<BlogSettingResponse> {
            return localVarFp.getBlogSetting(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BlogSettingApiPutBlogSettingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBlogSetting(requestParameters: BlogSettingApiPutBlogSettingRequest, options?: RawAxiosRequestConfig): AxiosPromise<BlogSettingResponse> {
            return localVarFp.putBlogSetting(requestParameters.blogSettingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getBlogSetting operation in BlogSettingApi.
 * @export
 * @interface BlogSettingApiGetBlogSettingRequest
 */
export interface BlogSettingApiGetBlogSettingRequest {
    /**
     * Sort by attributes ascending (asc) or descending (desc)
     * @type {string}
     * @memberof BlogSettingApiGetBlogSetting
     */
    readonly sort?: string

    /**
     * Return page/pageSize (default: true)
     * @type {boolean}
     * @memberof BlogSettingApiGetBlogSetting
     */
    readonly paginationWithCount?: boolean

    /**
     * Page number (default: 0)
     * @type {number}
     * @memberof BlogSettingApiGetBlogSetting
     */
    readonly paginationPage?: number

    /**
     * Page size (default: 25)
     * @type {number}
     * @memberof BlogSettingApiGetBlogSetting
     */
    readonly paginationPageSize?: number

    /**
     * Offset value (default: 0)
     * @type {number}
     * @memberof BlogSettingApiGetBlogSetting
     */
    readonly paginationStart?: number

    /**
     * Number of entities to return (default: 25)
     * @type {number}
     * @memberof BlogSettingApiGetBlogSetting
     */
    readonly paginationLimit?: number

    /**
     * Fields to return (ex: title,author)
     * @type {string}
     * @memberof BlogSettingApiGetBlogSetting
     */
    readonly fields?: string

    /**
     * Relations to return
     * @type {string}
     * @memberof BlogSettingApiGetBlogSetting
     */
    readonly populate?: string

    /**
     * Filters to apply
     * @type {{ [key: string]: any; }}
     * @memberof BlogSettingApiGetBlogSetting
     */
    readonly filters?: { [key: string]: any; }

    /**
     * Locale to apply
     * @type {string}
     * @memberof BlogSettingApiGetBlogSetting
     */
    readonly locale?: string
}

/**
 * Request parameters for putBlogSetting operation in BlogSettingApi.
 * @export
 * @interface BlogSettingApiPutBlogSettingRequest
 */
export interface BlogSettingApiPutBlogSettingRequest {
    /**
     * 
     * @type {BlogSettingRequest}
     * @memberof BlogSettingApiPutBlogSetting
     */
    readonly blogSettingRequest: BlogSettingRequest
}

/**
 * BlogSettingApi - object-oriented interface
 * @export
 * @class BlogSettingApi
 * @extends {BaseAPI}
 */
export class BlogSettingApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogSettingApi
     */
    public deleteBlogSetting(options?: RawAxiosRequestConfig) {
        return BlogSettingApiFp(this.configuration).deleteBlogSetting(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BlogSettingApiGetBlogSettingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogSettingApi
     */
    public getBlogSetting(requestParameters: BlogSettingApiGetBlogSettingRequest = {}, options?: RawAxiosRequestConfig) {
        return BlogSettingApiFp(this.configuration).getBlogSetting(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BlogSettingApiPutBlogSettingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogSettingApi
     */
    public putBlogSetting(requestParameters: BlogSettingApiPutBlogSettingRequest, options?: RawAxiosRequestConfig) {
        return BlogSettingApiFp(this.configuration).putBlogSetting(requestParameters.blogSettingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoriesId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCategoriesId', 'id', id)
            const localVarPath = `/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: async (sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (paginationWithCount !== undefined) {
                localVarQueryParameter['pagination[withCount]'] = paginationWithCount;
            }

            if (paginationPage !== undefined) {
                localVarQueryParameter['pagination[page]'] = paginationPage;
            }

            if (paginationPageSize !== undefined) {
                localVarQueryParameter['pagination[pageSize]'] = paginationPageSize;
            }

            if (paginationStart !== undefined) {
                localVarQueryParameter['pagination[start]'] = paginationStart;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination[limit]'] = paginationLimit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (populate !== undefined) {
                localVarQueryParameter['populate'] = populate;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCategoriesId', 'id', id)
            const localVarPath = `/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CategoryRequest} categoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategories: async (categoryRequest: CategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryRequest' is not null or undefined
            assertParamExists('postCategories', 'categoryRequest', categoryRequest)
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {CategoryRequest} categoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCategoriesId: async (id: number, categoryRequest: CategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putCategoriesId', 'id', id)
            // verify required parameter 'categoryRequest' is not null or undefined
            assertParamExists('putCategoriesId', 'categoryRequest', categoryRequest)
            const localVarPath = `/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategoriesId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategoriesId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.deleteCategoriesId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategories(sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategories(sort, paginationWithCount, paginationPage, paginationPageSize, paginationStart, paginationLimit, fields, populate, filters, locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.getCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoriesId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoriesId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.getCategoriesId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CategoryRequest} categoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCategories(categoryRequest: CategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCategories(categoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.postCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {CategoryRequest} categoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCategoriesId(id: number, categoryRequest: CategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCategoriesId(id, categoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.putCategoriesId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         * 
         * @param {CategoryApiDeleteCategoriesIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoriesId(requestParameters: CategoryApiDeleteCategoriesIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteCategoriesId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CategoryApiGetCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(requestParameters: CategoryApiGetCategoriesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CategoryListResponse> {
            return localVarFp.getCategories(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CategoryApiGetCategoriesIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesId(requestParameters: CategoryApiGetCategoriesIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<CategoryResponse> {
            return localVarFp.getCategoriesId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CategoryApiPostCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategories(requestParameters: CategoryApiPostCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<CategoryResponse> {
            return localVarFp.postCategories(requestParameters.categoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CategoryApiPutCategoriesIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCategoriesId(requestParameters: CategoryApiPutCategoriesIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<CategoryResponse> {
            return localVarFp.putCategoriesId(requestParameters.id, requestParameters.categoryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteCategoriesId operation in CategoryApi.
 * @export
 * @interface CategoryApiDeleteCategoriesIdRequest
 */
export interface CategoryApiDeleteCategoriesIdRequest {
    /**
     * 
     * @type {number}
     * @memberof CategoryApiDeleteCategoriesId
     */
    readonly id: number
}

/**
 * Request parameters for getCategories operation in CategoryApi.
 * @export
 * @interface CategoryApiGetCategoriesRequest
 */
export interface CategoryApiGetCategoriesRequest {
    /**
     * Sort by attributes ascending (asc) or descending (desc)
     * @type {string}
     * @memberof CategoryApiGetCategories
     */
    readonly sort?: string

    /**
     * Return page/pageSize (default: true)
     * @type {boolean}
     * @memberof CategoryApiGetCategories
     */
    readonly paginationWithCount?: boolean

    /**
     * Page number (default: 0)
     * @type {number}
     * @memberof CategoryApiGetCategories
     */
    readonly paginationPage?: number

    /**
     * Page size (default: 25)
     * @type {number}
     * @memberof CategoryApiGetCategories
     */
    readonly paginationPageSize?: number

    /**
     * Offset value (default: 0)
     * @type {number}
     * @memberof CategoryApiGetCategories
     */
    readonly paginationStart?: number

    /**
     * Number of entities to return (default: 25)
     * @type {number}
     * @memberof CategoryApiGetCategories
     */
    readonly paginationLimit?: number

    /**
     * Fields to return (ex: title,author)
     * @type {string}
     * @memberof CategoryApiGetCategories
     */
    readonly fields?: string

    /**
     * Relations to return
     * @type {string}
     * @memberof CategoryApiGetCategories
     */
    readonly populate?: string

    /**
     * Filters to apply
     * @type {{ [key: string]: any; }}
     * @memberof CategoryApiGetCategories
     */
    readonly filters?: { [key: string]: any; }

    /**
     * Locale to apply
     * @type {string}
     * @memberof CategoryApiGetCategories
     */
    readonly locale?: string
}

/**
 * Request parameters for getCategoriesId operation in CategoryApi.
 * @export
 * @interface CategoryApiGetCategoriesIdRequest
 */
export interface CategoryApiGetCategoriesIdRequest {
    /**
     * 
     * @type {number}
     * @memberof CategoryApiGetCategoriesId
     */
    readonly id: number
}

/**
 * Request parameters for postCategories operation in CategoryApi.
 * @export
 * @interface CategoryApiPostCategoriesRequest
 */
export interface CategoryApiPostCategoriesRequest {
    /**
     * 
     * @type {CategoryRequest}
     * @memberof CategoryApiPostCategories
     */
    readonly categoryRequest: CategoryRequest
}

/**
 * Request parameters for putCategoriesId operation in CategoryApi.
 * @export
 * @interface CategoryApiPutCategoriesIdRequest
 */
export interface CategoryApiPutCategoriesIdRequest {
    /**
     * 
     * @type {number}
     * @memberof CategoryApiPutCategoriesId
     */
    readonly id: number

    /**
     * 
     * @type {CategoryRequest}
     * @memberof CategoryApiPutCategoriesId
     */
    readonly categoryRequest: CategoryRequest
}

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * 
     * @param {CategoryApiDeleteCategoriesIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public deleteCategoriesId(requestParameters: CategoryApiDeleteCategoriesIdRequest, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).deleteCategoriesId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CategoryApiGetCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public getCategories(requestParameters: CategoryApiGetCategoriesRequest = {}, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).getCategories(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CategoryApiGetCategoriesIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public getCategoriesId(requestParameters: CategoryApiGetCategoriesIdRequest, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).getCategoriesId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CategoryApiPostCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public postCategories(requestParameters: CategoryApiPostCategoriesRequest, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).postCategories(requestParameters.categoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CategoryApiPutCategoriesIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public putCategoriesId(requestParameters: CategoryApiPutCategoriesIdRequest, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).putCategoriesId(requestParameters.id, requestParameters.categoryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FormationApi - axios parameter creator
 * @export
 */
export const FormationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFormationsId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFormationsId', 'id', id)
            const localVarPath = `/formations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormations: async (sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/formations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (paginationWithCount !== undefined) {
                localVarQueryParameter['pagination[withCount]'] = paginationWithCount;
            }

            if (paginationPage !== undefined) {
                localVarQueryParameter['pagination[page]'] = paginationPage;
            }

            if (paginationPageSize !== undefined) {
                localVarQueryParameter['pagination[pageSize]'] = paginationPageSize;
            }

            if (paginationStart !== undefined) {
                localVarQueryParameter['pagination[start]'] = paginationStart;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination[limit]'] = paginationLimit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (populate !== undefined) {
                localVarQueryParameter['populate'] = populate;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormationsId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFormationsId', 'id', id)
            const localVarPath = `/formations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FormationRequest} formationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFormations: async (formationRequest: FormationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'formationRequest' is not null or undefined
            assertParamExists('postFormations', 'formationRequest', formationRequest)
            const localVarPath = `/formations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {FormationRequest} formationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFormationsId: async (id: number, formationRequest: FormationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putFormationsId', 'id', id)
            // verify required parameter 'formationRequest' is not null or undefined
            assertParamExists('putFormationsId', 'formationRequest', formationRequest)
            const localVarPath = `/formations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormationApi - functional programming interface
 * @export
 */
export const FormationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FormationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFormationsId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFormationsId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormationApi.deleteFormationsId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFormations(sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormationListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFormations(sort, paginationWithCount, paginationPage, paginationPageSize, paginationStart, paginationLimit, fields, populate, filters, locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormationApi.getFormations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFormationsId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFormationsId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormationApi.getFormationsId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FormationRequest} formationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFormations(formationRequest: FormationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFormations(formationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormationApi.postFormations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {FormationRequest} formationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFormationsId(id: number, formationRequest: FormationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFormationsId(id, formationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormationApi.putFormationsId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FormationApi - factory interface
 * @export
 */
export const FormationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FormationApiFp(configuration)
    return {
        /**
         * 
         * @param {FormationApiDeleteFormationsIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFormationsId(requestParameters: FormationApiDeleteFormationsIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteFormationsId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FormationApiGetFormationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormations(requestParameters: FormationApiGetFormationsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<FormationListResponse> {
            return localVarFp.getFormations(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FormationApiGetFormationsIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormationsId(requestParameters: FormationApiGetFormationsIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<FormationResponse> {
            return localVarFp.getFormationsId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FormationApiPostFormationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFormations(requestParameters: FormationApiPostFormationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<FormationResponse> {
            return localVarFp.postFormations(requestParameters.formationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FormationApiPutFormationsIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFormationsId(requestParameters: FormationApiPutFormationsIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<FormationResponse> {
            return localVarFp.putFormationsId(requestParameters.id, requestParameters.formationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteFormationsId operation in FormationApi.
 * @export
 * @interface FormationApiDeleteFormationsIdRequest
 */
export interface FormationApiDeleteFormationsIdRequest {
    /**
     * 
     * @type {number}
     * @memberof FormationApiDeleteFormationsId
     */
    readonly id: number
}

/**
 * Request parameters for getFormations operation in FormationApi.
 * @export
 * @interface FormationApiGetFormationsRequest
 */
export interface FormationApiGetFormationsRequest {
    /**
     * Sort by attributes ascending (asc) or descending (desc)
     * @type {string}
     * @memberof FormationApiGetFormations
     */
    readonly sort?: string

    /**
     * Return page/pageSize (default: true)
     * @type {boolean}
     * @memberof FormationApiGetFormations
     */
    readonly paginationWithCount?: boolean

    /**
     * Page number (default: 0)
     * @type {number}
     * @memberof FormationApiGetFormations
     */
    readonly paginationPage?: number

    /**
     * Page size (default: 25)
     * @type {number}
     * @memberof FormationApiGetFormations
     */
    readonly paginationPageSize?: number

    /**
     * Offset value (default: 0)
     * @type {number}
     * @memberof FormationApiGetFormations
     */
    readonly paginationStart?: number

    /**
     * Number of entities to return (default: 25)
     * @type {number}
     * @memberof FormationApiGetFormations
     */
    readonly paginationLimit?: number

    /**
     * Fields to return (ex: title,author)
     * @type {string}
     * @memberof FormationApiGetFormations
     */
    readonly fields?: string

    /**
     * Relations to return
     * @type {string}
     * @memberof FormationApiGetFormations
     */
    readonly populate?: string

    /**
     * Filters to apply
     * @type {{ [key: string]: any; }}
     * @memberof FormationApiGetFormations
     */
    readonly filters?: { [key: string]: any; }

    /**
     * Locale to apply
     * @type {string}
     * @memberof FormationApiGetFormations
     */
    readonly locale?: string
}

/**
 * Request parameters for getFormationsId operation in FormationApi.
 * @export
 * @interface FormationApiGetFormationsIdRequest
 */
export interface FormationApiGetFormationsIdRequest {
    /**
     * 
     * @type {number}
     * @memberof FormationApiGetFormationsId
     */
    readonly id: number
}

/**
 * Request parameters for postFormations operation in FormationApi.
 * @export
 * @interface FormationApiPostFormationsRequest
 */
export interface FormationApiPostFormationsRequest {
    /**
     * 
     * @type {FormationRequest}
     * @memberof FormationApiPostFormations
     */
    readonly formationRequest: FormationRequest
}

/**
 * Request parameters for putFormationsId operation in FormationApi.
 * @export
 * @interface FormationApiPutFormationsIdRequest
 */
export interface FormationApiPutFormationsIdRequest {
    /**
     * 
     * @type {number}
     * @memberof FormationApiPutFormationsId
     */
    readonly id: number

    /**
     * 
     * @type {FormationRequest}
     * @memberof FormationApiPutFormationsId
     */
    readonly formationRequest: FormationRequest
}

/**
 * FormationApi - object-oriented interface
 * @export
 * @class FormationApi
 * @extends {BaseAPI}
 */
export class FormationApi extends BaseAPI {
    /**
     * 
     * @param {FormationApiDeleteFormationsIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormationApi
     */
    public deleteFormationsId(requestParameters: FormationApiDeleteFormationsIdRequest, options?: RawAxiosRequestConfig) {
        return FormationApiFp(this.configuration).deleteFormationsId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FormationApiGetFormationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormationApi
     */
    public getFormations(requestParameters: FormationApiGetFormationsRequest = {}, options?: RawAxiosRequestConfig) {
        return FormationApiFp(this.configuration).getFormations(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FormationApiGetFormationsIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormationApi
     */
    public getFormationsId(requestParameters: FormationApiGetFormationsIdRequest, options?: RawAxiosRequestConfig) {
        return FormationApiFp(this.configuration).getFormationsId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FormationApiPostFormationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormationApi
     */
    public postFormations(requestParameters: FormationApiPostFormationsRequest, options?: RawAxiosRequestConfig) {
        return FormationApiFp(this.configuration).postFormations(requestParameters.formationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FormationApiPutFormationsIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormationApi
     */
    public putFormationsId(requestParameters: FormationApiPutFormationsIdRequest, options?: RawAxiosRequestConfig) {
        return FormationApiFp(this.configuration).putFormationsId(requestParameters.id, requestParameters.formationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FormationSettingApi - axios parameter creator
 * @export
 */
export const FormationSettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFormationSetting: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/formation-setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormationSetting: async (sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/formation-setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (paginationWithCount !== undefined) {
                localVarQueryParameter['pagination[withCount]'] = paginationWithCount;
            }

            if (paginationPage !== undefined) {
                localVarQueryParameter['pagination[page]'] = paginationPage;
            }

            if (paginationPageSize !== undefined) {
                localVarQueryParameter['pagination[pageSize]'] = paginationPageSize;
            }

            if (paginationStart !== undefined) {
                localVarQueryParameter['pagination[start]'] = paginationStart;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination[limit]'] = paginationLimit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (populate !== undefined) {
                localVarQueryParameter['populate'] = populate;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FormationSettingRequest} formationSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFormationSetting: async (formationSettingRequest: FormationSettingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'formationSettingRequest' is not null or undefined
            assertParamExists('putFormationSetting', 'formationSettingRequest', formationSettingRequest)
            const localVarPath = `/formation-setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formationSettingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormationSettingApi - functional programming interface
 * @export
 */
export const FormationSettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FormationSettingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFormationSetting(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFormationSetting(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormationSettingApi.deleteFormationSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFormationSetting(sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormationSettingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFormationSetting(sort, paginationWithCount, paginationPage, paginationPageSize, paginationStart, paginationLimit, fields, populate, filters, locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormationSettingApi.getFormationSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FormationSettingRequest} formationSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFormationSetting(formationSettingRequest: FormationSettingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormationSettingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFormationSetting(formationSettingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormationSettingApi.putFormationSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FormationSettingApi - factory interface
 * @export
 */
export const FormationSettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FormationSettingApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFormationSetting(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteFormationSetting(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FormationSettingApiGetFormationSettingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormationSetting(requestParameters: FormationSettingApiGetFormationSettingRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<FormationSettingResponse> {
            return localVarFp.getFormationSetting(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FormationSettingApiPutFormationSettingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFormationSetting(requestParameters: FormationSettingApiPutFormationSettingRequest, options?: RawAxiosRequestConfig): AxiosPromise<FormationSettingResponse> {
            return localVarFp.putFormationSetting(requestParameters.formationSettingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFormationSetting operation in FormationSettingApi.
 * @export
 * @interface FormationSettingApiGetFormationSettingRequest
 */
export interface FormationSettingApiGetFormationSettingRequest {
    /**
     * Sort by attributes ascending (asc) or descending (desc)
     * @type {string}
     * @memberof FormationSettingApiGetFormationSetting
     */
    readonly sort?: string

    /**
     * Return page/pageSize (default: true)
     * @type {boolean}
     * @memberof FormationSettingApiGetFormationSetting
     */
    readonly paginationWithCount?: boolean

    /**
     * Page number (default: 0)
     * @type {number}
     * @memberof FormationSettingApiGetFormationSetting
     */
    readonly paginationPage?: number

    /**
     * Page size (default: 25)
     * @type {number}
     * @memberof FormationSettingApiGetFormationSetting
     */
    readonly paginationPageSize?: number

    /**
     * Offset value (default: 0)
     * @type {number}
     * @memberof FormationSettingApiGetFormationSetting
     */
    readonly paginationStart?: number

    /**
     * Number of entities to return (default: 25)
     * @type {number}
     * @memberof FormationSettingApiGetFormationSetting
     */
    readonly paginationLimit?: number

    /**
     * Fields to return (ex: title,author)
     * @type {string}
     * @memberof FormationSettingApiGetFormationSetting
     */
    readonly fields?: string

    /**
     * Relations to return
     * @type {string}
     * @memberof FormationSettingApiGetFormationSetting
     */
    readonly populate?: string

    /**
     * Filters to apply
     * @type {{ [key: string]: any; }}
     * @memberof FormationSettingApiGetFormationSetting
     */
    readonly filters?: { [key: string]: any; }

    /**
     * Locale to apply
     * @type {string}
     * @memberof FormationSettingApiGetFormationSetting
     */
    readonly locale?: string
}

/**
 * Request parameters for putFormationSetting operation in FormationSettingApi.
 * @export
 * @interface FormationSettingApiPutFormationSettingRequest
 */
export interface FormationSettingApiPutFormationSettingRequest {
    /**
     * 
     * @type {FormationSettingRequest}
     * @memberof FormationSettingApiPutFormationSetting
     */
    readonly formationSettingRequest: FormationSettingRequest
}

/**
 * FormationSettingApi - object-oriented interface
 * @export
 * @class FormationSettingApi
 * @extends {BaseAPI}
 */
export class FormationSettingApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormationSettingApi
     */
    public deleteFormationSetting(options?: RawAxiosRequestConfig) {
        return FormationSettingApiFp(this.configuration).deleteFormationSetting(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FormationSettingApiGetFormationSettingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormationSettingApi
     */
    public getFormationSetting(requestParameters: FormationSettingApiGetFormationSettingRequest = {}, options?: RawAxiosRequestConfig) {
        return FormationSettingApiFp(this.configuration).getFormationSetting(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FormationSettingApiPutFormationSettingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormationSettingApi
     */
    public putFormationSetting(requestParameters: FormationSettingApiPutFormationSettingRequest, options?: RawAxiosRequestConfig) {
        return FormationSettingApiFp(this.configuration).putFormationSetting(requestParameters.formationSettingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HomeSettingApi - axios parameter creator
 * @export
 */
export const HomeSettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHomeSetting: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/home-setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHomeSetting: async (sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/home-setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (paginationWithCount !== undefined) {
                localVarQueryParameter['pagination[withCount]'] = paginationWithCount;
            }

            if (paginationPage !== undefined) {
                localVarQueryParameter['pagination[page]'] = paginationPage;
            }

            if (paginationPageSize !== undefined) {
                localVarQueryParameter['pagination[pageSize]'] = paginationPageSize;
            }

            if (paginationStart !== undefined) {
                localVarQueryParameter['pagination[start]'] = paginationStart;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination[limit]'] = paginationLimit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (populate !== undefined) {
                localVarQueryParameter['populate'] = populate;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {HomeSettingRequest} homeSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putHomeSetting: async (homeSettingRequest: HomeSettingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'homeSettingRequest' is not null or undefined
            assertParamExists('putHomeSetting', 'homeSettingRequest', homeSettingRequest)
            const localVarPath = `/home-setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(homeSettingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HomeSettingApi - functional programming interface
 * @export
 */
export const HomeSettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HomeSettingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHomeSetting(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHomeSetting(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HomeSettingApi.deleteHomeSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHomeSetting(sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HomeSettingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHomeSetting(sort, paginationWithCount, paginationPage, paginationPageSize, paginationStart, paginationLimit, fields, populate, filters, locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HomeSettingApi.getHomeSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {HomeSettingRequest} homeSettingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putHomeSetting(homeSettingRequest: HomeSettingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HomeSettingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putHomeSetting(homeSettingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HomeSettingApi.putHomeSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HomeSettingApi - factory interface
 * @export
 */
export const HomeSettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HomeSettingApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHomeSetting(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteHomeSetting(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {HomeSettingApiGetHomeSettingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHomeSetting(requestParameters: HomeSettingApiGetHomeSettingRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<HomeSettingResponse> {
            return localVarFp.getHomeSetting(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {HomeSettingApiPutHomeSettingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putHomeSetting(requestParameters: HomeSettingApiPutHomeSettingRequest, options?: RawAxiosRequestConfig): AxiosPromise<HomeSettingResponse> {
            return localVarFp.putHomeSetting(requestParameters.homeSettingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getHomeSetting operation in HomeSettingApi.
 * @export
 * @interface HomeSettingApiGetHomeSettingRequest
 */
export interface HomeSettingApiGetHomeSettingRequest {
    /**
     * Sort by attributes ascending (asc) or descending (desc)
     * @type {string}
     * @memberof HomeSettingApiGetHomeSetting
     */
    readonly sort?: string

    /**
     * Return page/pageSize (default: true)
     * @type {boolean}
     * @memberof HomeSettingApiGetHomeSetting
     */
    readonly paginationWithCount?: boolean

    /**
     * Page number (default: 0)
     * @type {number}
     * @memberof HomeSettingApiGetHomeSetting
     */
    readonly paginationPage?: number

    /**
     * Page size (default: 25)
     * @type {number}
     * @memberof HomeSettingApiGetHomeSetting
     */
    readonly paginationPageSize?: number

    /**
     * Offset value (default: 0)
     * @type {number}
     * @memberof HomeSettingApiGetHomeSetting
     */
    readonly paginationStart?: number

    /**
     * Number of entities to return (default: 25)
     * @type {number}
     * @memberof HomeSettingApiGetHomeSetting
     */
    readonly paginationLimit?: number

    /**
     * Fields to return (ex: title,author)
     * @type {string}
     * @memberof HomeSettingApiGetHomeSetting
     */
    readonly fields?: string

    /**
     * Relations to return
     * @type {string}
     * @memberof HomeSettingApiGetHomeSetting
     */
    readonly populate?: string

    /**
     * Filters to apply
     * @type {{ [key: string]: any; }}
     * @memberof HomeSettingApiGetHomeSetting
     */
    readonly filters?: { [key: string]: any; }

    /**
     * Locale to apply
     * @type {string}
     * @memberof HomeSettingApiGetHomeSetting
     */
    readonly locale?: string
}

/**
 * Request parameters for putHomeSetting operation in HomeSettingApi.
 * @export
 * @interface HomeSettingApiPutHomeSettingRequest
 */
export interface HomeSettingApiPutHomeSettingRequest {
    /**
     * 
     * @type {HomeSettingRequest}
     * @memberof HomeSettingApiPutHomeSetting
     */
    readonly homeSettingRequest: HomeSettingRequest
}

/**
 * HomeSettingApi - object-oriented interface
 * @export
 * @class HomeSettingApi
 * @extends {BaseAPI}
 */
export class HomeSettingApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HomeSettingApi
     */
    public deleteHomeSetting(options?: RawAxiosRequestConfig) {
        return HomeSettingApiFp(this.configuration).deleteHomeSetting(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HomeSettingApiGetHomeSettingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HomeSettingApi
     */
    public getHomeSetting(requestParameters: HomeSettingApiGetHomeSettingRequest = {}, options?: RawAxiosRequestConfig) {
        return HomeSettingApiFp(this.configuration).getHomeSetting(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HomeSettingApiPutHomeSettingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HomeSettingApi
     */
    public putHomeSetting(requestParameters: HomeSettingApiPutHomeSettingRequest, options?: RawAxiosRequestConfig) {
        return HomeSettingApiFp(this.configuration).putHomeSetting(requestParameters.homeSettingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartnerApi - axios parameter creator
 * @export
 */
export const PartnerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartnersId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePartnersId', 'id', id)
            const localVarPath = `/partners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartners: async (sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (paginationWithCount !== undefined) {
                localVarQueryParameter['pagination[withCount]'] = paginationWithCount;
            }

            if (paginationPage !== undefined) {
                localVarQueryParameter['pagination[page]'] = paginationPage;
            }

            if (paginationPageSize !== undefined) {
                localVarQueryParameter['pagination[pageSize]'] = paginationPageSize;
            }

            if (paginationStart !== undefined) {
                localVarQueryParameter['pagination[start]'] = paginationStart;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination[limit]'] = paginationLimit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (populate !== undefined) {
                localVarQueryParameter['populate'] = populate;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartnersId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPartnersId', 'id', id)
            const localVarPath = `/partners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PartnerRequest} partnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPartners: async (partnerRequest: PartnerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partnerRequest' is not null or undefined
            assertParamExists('postPartners', 'partnerRequest', partnerRequest)
            const localVarPath = `/partners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PartnerRequest} partnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPartnersId: async (id: number, partnerRequest: PartnerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putPartnersId', 'id', id)
            // verify required parameter 'partnerRequest' is not null or undefined
            assertParamExists('putPartnersId', 'partnerRequest', partnerRequest)
            const localVarPath = `/partners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnerApi - functional programming interface
 * @export
 */
export const PartnerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePartnersId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePartnersId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.deletePartnersId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartners(sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartners(sort, paginationWithCount, paginationPage, paginationPageSize, paginationStart, paginationLimit, fields, populate, filters, locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.getPartners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartnersId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartnersId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.getPartnersId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PartnerRequest} partnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPartners(partnerRequest: PartnerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPartners(partnerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.postPartners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {PartnerRequest} partnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putPartnersId(id: number, partnerRequest: PartnerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPartnersId(id, partnerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerApi.putPartnersId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartnerApi - factory interface
 * @export
 */
export const PartnerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnerApiFp(configuration)
    return {
        /**
         * 
         * @param {PartnerApiDeletePartnersIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartnersId(requestParameters: PartnerApiDeletePartnersIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deletePartnersId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PartnerApiGetPartnersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartners(requestParameters: PartnerApiGetPartnersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PartnerListResponse> {
            return localVarFp.getPartners(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PartnerApiGetPartnersIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartnersId(requestParameters: PartnerApiGetPartnersIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerResponse> {
            return localVarFp.getPartnersId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PartnerApiPostPartnersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPartners(requestParameters: PartnerApiPostPartnersRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerResponse> {
            return localVarFp.postPartners(requestParameters.partnerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PartnerApiPutPartnersIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPartnersId(requestParameters: PartnerApiPutPartnersIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<PartnerResponse> {
            return localVarFp.putPartnersId(requestParameters.id, requestParameters.partnerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deletePartnersId operation in PartnerApi.
 * @export
 * @interface PartnerApiDeletePartnersIdRequest
 */
export interface PartnerApiDeletePartnersIdRequest {
    /**
     * 
     * @type {number}
     * @memberof PartnerApiDeletePartnersId
     */
    readonly id: number
}

/**
 * Request parameters for getPartners operation in PartnerApi.
 * @export
 * @interface PartnerApiGetPartnersRequest
 */
export interface PartnerApiGetPartnersRequest {
    /**
     * Sort by attributes ascending (asc) or descending (desc)
     * @type {string}
     * @memberof PartnerApiGetPartners
     */
    readonly sort?: string

    /**
     * Return page/pageSize (default: true)
     * @type {boolean}
     * @memberof PartnerApiGetPartners
     */
    readonly paginationWithCount?: boolean

    /**
     * Page number (default: 0)
     * @type {number}
     * @memberof PartnerApiGetPartners
     */
    readonly paginationPage?: number

    /**
     * Page size (default: 25)
     * @type {number}
     * @memberof PartnerApiGetPartners
     */
    readonly paginationPageSize?: number

    /**
     * Offset value (default: 0)
     * @type {number}
     * @memberof PartnerApiGetPartners
     */
    readonly paginationStart?: number

    /**
     * Number of entities to return (default: 25)
     * @type {number}
     * @memberof PartnerApiGetPartners
     */
    readonly paginationLimit?: number

    /**
     * Fields to return (ex: title,author)
     * @type {string}
     * @memberof PartnerApiGetPartners
     */
    readonly fields?: string

    /**
     * Relations to return
     * @type {string}
     * @memberof PartnerApiGetPartners
     */
    readonly populate?: string

    /**
     * Filters to apply
     * @type {{ [key: string]: any; }}
     * @memberof PartnerApiGetPartners
     */
    readonly filters?: { [key: string]: any; }

    /**
     * Locale to apply
     * @type {string}
     * @memberof PartnerApiGetPartners
     */
    readonly locale?: string
}

/**
 * Request parameters for getPartnersId operation in PartnerApi.
 * @export
 * @interface PartnerApiGetPartnersIdRequest
 */
export interface PartnerApiGetPartnersIdRequest {
    /**
     * 
     * @type {number}
     * @memberof PartnerApiGetPartnersId
     */
    readonly id: number
}

/**
 * Request parameters for postPartners operation in PartnerApi.
 * @export
 * @interface PartnerApiPostPartnersRequest
 */
export interface PartnerApiPostPartnersRequest {
    /**
     * 
     * @type {PartnerRequest}
     * @memberof PartnerApiPostPartners
     */
    readonly partnerRequest: PartnerRequest
}

/**
 * Request parameters for putPartnersId operation in PartnerApi.
 * @export
 * @interface PartnerApiPutPartnersIdRequest
 */
export interface PartnerApiPutPartnersIdRequest {
    /**
     * 
     * @type {number}
     * @memberof PartnerApiPutPartnersId
     */
    readonly id: number

    /**
     * 
     * @type {PartnerRequest}
     * @memberof PartnerApiPutPartnersId
     */
    readonly partnerRequest: PartnerRequest
}

/**
 * PartnerApi - object-oriented interface
 * @export
 * @class PartnerApi
 * @extends {BaseAPI}
 */
export class PartnerApi extends BaseAPI {
    /**
     * 
     * @param {PartnerApiDeletePartnersIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public deletePartnersId(requestParameters: PartnerApiDeletePartnersIdRequest, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).deletePartnersId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PartnerApiGetPartnersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public getPartners(requestParameters: PartnerApiGetPartnersRequest = {}, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).getPartners(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PartnerApiGetPartnersIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public getPartnersId(requestParameters: PartnerApiGetPartnersIdRequest, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).getPartnersId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PartnerApiPostPartnersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public postPartners(requestParameters: PartnerApiPostPartnersRequest, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).postPartners(requestParameters.partnerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PartnerApiPutPartnersIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public putPartnersId(requestParameters: PartnerApiPutPartnersIdRequest, options?: RawAxiosRequestConfig) {
        return PartnerApiFp(this.configuration).putPartnersId(requestParameters.id, requestParameters.partnerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestimonyApi - axios parameter creator
 * @export
 */
export const TestimonyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTestimoniesId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTestimoniesId', 'id', id)
            const localVarPath = `/testimonies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestimonies: async (sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/testimonies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (paginationWithCount !== undefined) {
                localVarQueryParameter['pagination[withCount]'] = paginationWithCount;
            }

            if (paginationPage !== undefined) {
                localVarQueryParameter['pagination[page]'] = paginationPage;
            }

            if (paginationPageSize !== undefined) {
                localVarQueryParameter['pagination[pageSize]'] = paginationPageSize;
            }

            if (paginationStart !== undefined) {
                localVarQueryParameter['pagination[start]'] = paginationStart;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination[limit]'] = paginationLimit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (populate !== undefined) {
                localVarQueryParameter['populate'] = populate;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestimoniesId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTestimoniesId', 'id', id)
            const localVarPath = `/testimonies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TestimonyRequest} testimonyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTestimonies: async (testimonyRequest: TestimonyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testimonyRequest' is not null or undefined
            assertParamExists('postTestimonies', 'testimonyRequest', testimonyRequest)
            const localVarPath = `/testimonies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testimonyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {TestimonyRequest} testimonyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTestimoniesId: async (id: number, testimonyRequest: TestimonyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putTestimoniesId', 'id', id)
            // verify required parameter 'testimonyRequest' is not null or undefined
            assertParamExists('putTestimoniesId', 'testimonyRequest', testimonyRequest)
            const localVarPath = `/testimonies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testimonyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestimonyApi - functional programming interface
 * @export
 */
export const TestimonyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestimonyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTestimoniesId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTestimoniesId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonyApi.deleteTestimoniesId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sort] Sort by attributes ascending (asc) or descending (desc)
         * @param {boolean} [paginationWithCount] Return page/pageSize (default: true)
         * @param {number} [paginationPage] Page number (default: 0)
         * @param {number} [paginationPageSize] Page size (default: 25)
         * @param {number} [paginationStart] Offset value (default: 0)
         * @param {number} [paginationLimit] Number of entities to return (default: 25)
         * @param {string} [fields] Fields to return (ex: title,author)
         * @param {string} [populate] Relations to return
         * @param {{ [key: string]: any; }} [filters] Filters to apply
         * @param {string} [locale] Locale to apply
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestimonies(sort?: string, paginationWithCount?: boolean, paginationPage?: number, paginationPageSize?: number, paginationStart?: number, paginationLimit?: number, fields?: string, populate?: string, filters?: { [key: string]: any; }, locale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestimonyListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestimonies(sort, paginationWithCount, paginationPage, paginationPageSize, paginationStart, paginationLimit, fields, populate, filters, locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonyApi.getTestimonies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestimoniesId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestimonyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTestimoniesId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonyApi.getTestimoniesId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TestimonyRequest} testimonyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTestimonies(testimonyRequest: TestimonyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestimonyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTestimonies(testimonyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonyApi.postTestimonies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {TestimonyRequest} testimonyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTestimoniesId(id: number, testimonyRequest: TestimonyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestimonyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putTestimoniesId(id, testimonyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonyApi.putTestimoniesId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TestimonyApi - factory interface
 * @export
 */
export const TestimonyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestimonyApiFp(configuration)
    return {
        /**
         * 
         * @param {TestimonyApiDeleteTestimoniesIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTestimoniesId(requestParameters: TestimonyApiDeleteTestimoniesIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteTestimoniesId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TestimonyApiGetTestimoniesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestimonies(requestParameters: TestimonyApiGetTestimoniesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TestimonyListResponse> {
            return localVarFp.getTestimonies(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TestimonyApiGetTestimoniesIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestimoniesId(requestParameters: TestimonyApiGetTestimoniesIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<TestimonyResponse> {
            return localVarFp.getTestimoniesId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TestimonyApiPostTestimoniesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTestimonies(requestParameters: TestimonyApiPostTestimoniesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TestimonyResponse> {
            return localVarFp.postTestimonies(requestParameters.testimonyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TestimonyApiPutTestimoniesIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTestimoniesId(requestParameters: TestimonyApiPutTestimoniesIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<TestimonyResponse> {
            return localVarFp.putTestimoniesId(requestParameters.id, requestParameters.testimonyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteTestimoniesId operation in TestimonyApi.
 * @export
 * @interface TestimonyApiDeleteTestimoniesIdRequest
 */
export interface TestimonyApiDeleteTestimoniesIdRequest {
    /**
     * 
     * @type {number}
     * @memberof TestimonyApiDeleteTestimoniesId
     */
    readonly id: number
}

/**
 * Request parameters for getTestimonies operation in TestimonyApi.
 * @export
 * @interface TestimonyApiGetTestimoniesRequest
 */
export interface TestimonyApiGetTestimoniesRequest {
    /**
     * Sort by attributes ascending (asc) or descending (desc)
     * @type {string}
     * @memberof TestimonyApiGetTestimonies
     */
    readonly sort?: string

    /**
     * Return page/pageSize (default: true)
     * @type {boolean}
     * @memberof TestimonyApiGetTestimonies
     */
    readonly paginationWithCount?: boolean

    /**
     * Page number (default: 0)
     * @type {number}
     * @memberof TestimonyApiGetTestimonies
     */
    readonly paginationPage?: number

    /**
     * Page size (default: 25)
     * @type {number}
     * @memberof TestimonyApiGetTestimonies
     */
    readonly paginationPageSize?: number

    /**
     * Offset value (default: 0)
     * @type {number}
     * @memberof TestimonyApiGetTestimonies
     */
    readonly paginationStart?: number

    /**
     * Number of entities to return (default: 25)
     * @type {number}
     * @memberof TestimonyApiGetTestimonies
     */
    readonly paginationLimit?: number

    /**
     * Fields to return (ex: title,author)
     * @type {string}
     * @memberof TestimonyApiGetTestimonies
     */
    readonly fields?: string

    /**
     * Relations to return
     * @type {string}
     * @memberof TestimonyApiGetTestimonies
     */
    readonly populate?: string

    /**
     * Filters to apply
     * @type {{ [key: string]: any; }}
     * @memberof TestimonyApiGetTestimonies
     */
    readonly filters?: { [key: string]: any; }

    /**
     * Locale to apply
     * @type {string}
     * @memberof TestimonyApiGetTestimonies
     */
    readonly locale?: string
}

/**
 * Request parameters for getTestimoniesId operation in TestimonyApi.
 * @export
 * @interface TestimonyApiGetTestimoniesIdRequest
 */
export interface TestimonyApiGetTestimoniesIdRequest {
    /**
     * 
     * @type {number}
     * @memberof TestimonyApiGetTestimoniesId
     */
    readonly id: number
}

/**
 * Request parameters for postTestimonies operation in TestimonyApi.
 * @export
 * @interface TestimonyApiPostTestimoniesRequest
 */
export interface TestimonyApiPostTestimoniesRequest {
    /**
     * 
     * @type {TestimonyRequest}
     * @memberof TestimonyApiPostTestimonies
     */
    readonly testimonyRequest: TestimonyRequest
}

/**
 * Request parameters for putTestimoniesId operation in TestimonyApi.
 * @export
 * @interface TestimonyApiPutTestimoniesIdRequest
 */
export interface TestimonyApiPutTestimoniesIdRequest {
    /**
     * 
     * @type {number}
     * @memberof TestimonyApiPutTestimoniesId
     */
    readonly id: number

    /**
     * 
     * @type {TestimonyRequest}
     * @memberof TestimonyApiPutTestimoniesId
     */
    readonly testimonyRequest: TestimonyRequest
}

/**
 * TestimonyApi - object-oriented interface
 * @export
 * @class TestimonyApi
 * @extends {BaseAPI}
 */
export class TestimonyApi extends BaseAPI {
    /**
     * 
     * @param {TestimonyApiDeleteTestimoniesIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonyApi
     */
    public deleteTestimoniesId(requestParameters: TestimonyApiDeleteTestimoniesIdRequest, options?: RawAxiosRequestConfig) {
        return TestimonyApiFp(this.configuration).deleteTestimoniesId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TestimonyApiGetTestimoniesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonyApi
     */
    public getTestimonies(requestParameters: TestimonyApiGetTestimoniesRequest = {}, options?: RawAxiosRequestConfig) {
        return TestimonyApiFp(this.configuration).getTestimonies(requestParameters.sort, requestParameters.paginationWithCount, requestParameters.paginationPage, requestParameters.paginationPageSize, requestParameters.paginationStart, requestParameters.paginationLimit, requestParameters.fields, requestParameters.populate, requestParameters.filters, requestParameters.locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TestimonyApiGetTestimoniesIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonyApi
     */
    public getTestimoniesId(requestParameters: TestimonyApiGetTestimoniesIdRequest, options?: RawAxiosRequestConfig) {
        return TestimonyApiFp(this.configuration).getTestimoniesId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TestimonyApiPostTestimoniesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonyApi
     */
    public postTestimonies(requestParameters: TestimonyApiPostTestimoniesRequest, options?: RawAxiosRequestConfig) {
        return TestimonyApiFp(this.configuration).postTestimonies(requestParameters.testimonyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TestimonyApiPutTestimoniesIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonyApi
     */
    public putTestimoniesId(requestParameters: TestimonyApiPutTestimoniesIdRequest, options?: RawAxiosRequestConfig) {
        return TestimonyApiFp(this.configuration).putTestimoniesId(requestParameters.id, requestParameters.testimonyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UploadFileApi - axios parameter creator
 * @export
 */
export const UploadFileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/upload/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadFilesIdDelete', 'id', id)
            const localVarPath = `/upload/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadFilesIdGet', 'id', id)
            const localVarPath = `/upload/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload files
         * @summary 
         * @param {Array<File>} files 
         * @param {string} [path] The folder where the file(s) will be uploaded to (only supported on strapi-provider-upload-aws-s3).
         * @param {string} [refId] The ID of the entry which the file(s) will be linked to
         * @param {string} [ref] The unique ID (uid) of the model which the file(s) will be linked to (api::restaurant.restaurant).
         * @param {string} [field] The field of the entry which the file(s) will be precisely linked to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPost: async (files: Array<File>, path?: string, refId?: string, ref?: string, field?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            assertParamExists('uploadPost', 'files', files)
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (path !== undefined) { 
                localVarFormParams.append('path', path as any);
            }
    
            if (refId !== undefined) { 
                localVarFormParams.append('refId', refId as any);
            }
    
            if (ref !== undefined) { 
                localVarFormParams.append('ref', ref as any);
            }
    
            if (field !== undefined) { 
                localVarFormParams.append('field', field as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload file information
         * @summary 
         * @param {string} id File id
         * @param {UploadIdIdPostRequestFileInfo} [fileInfo] 
         * @param {File} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadididPost: async (id: string, fileInfo?: UploadIdIdPostRequestFileInfo, files?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadididPost', 'id', id)
            const localVarPath = `/upload?id={id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


            if (fileInfo !== undefined) { 
                localVarFormParams.append('fileInfo', new Blob([JSON.stringify(fileInfo)], { type: "application/json", }));
            }
    
            if (files !== undefined) { 
                localVarFormParams.append('files', files as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadFileApi - functional programming interface
 * @export
 */
export const UploadFileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadFileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFilesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UploadFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFilesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadFileApi.uploadFilesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFilesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFilesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadFileApi.uploadFilesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFilesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFilesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadFileApi.uploadFilesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload files
         * @summary 
         * @param {Array<File>} files 
         * @param {string} [path] The folder where the file(s) will be uploaded to (only supported on strapi-provider-upload-aws-s3).
         * @param {string} [refId] The ID of the entry which the file(s) will be linked to
         * @param {string} [ref] The unique ID (uid) of the model which the file(s) will be linked to (api::restaurant.restaurant).
         * @param {string} [field] The field of the entry which the file(s) will be precisely linked to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPost(files: Array<File>, path?: string, refId?: string, ref?: string, field?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UploadFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPost(files, path, refId, ref, field, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadFileApi.uploadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload file information
         * @summary 
         * @param {string} id File id
         * @param {UploadIdIdPostRequestFileInfo} [fileInfo] 
         * @param {File} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadididPost(id: string, fileInfo?: UploadIdIdPostRequestFileInfo, files?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UploadFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadididPost(id, fileInfo, files, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadFileApi.uploadididPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UploadFileApi - factory interface
 * @export
 */
export const UploadFileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadFileApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<UploadFile>> {
            return localVarFp.uploadFilesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UploadFileApiUploadFilesIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesIdDelete(requestParameters: UploadFileApiUploadFilesIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadFile> {
            return localVarFp.uploadFilesIdDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UploadFileApiUploadFilesIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilesIdGet(requestParameters: UploadFileApiUploadFilesIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadFile> {
            return localVarFp.uploadFilesIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload files
         * @summary 
         * @param {UploadFileApiUploadPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPost(requestParameters: UploadFileApiUploadPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UploadFile>> {
            return localVarFp.uploadPost(requestParameters.files, requestParameters.path, requestParameters.refId, requestParameters.ref, requestParameters.field, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload file information
         * @summary 
         * @param {UploadFileApiUploadididPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadididPost(requestParameters: UploadFileApiUploadididPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UploadFile>> {
            return localVarFp.uploadididPost(requestParameters.id, requestParameters.fileInfo, requestParameters.files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for uploadFilesIdDelete operation in UploadFileApi.
 * @export
 * @interface UploadFileApiUploadFilesIdDeleteRequest
 */
export interface UploadFileApiUploadFilesIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof UploadFileApiUploadFilesIdDelete
     */
    readonly id: string
}

/**
 * Request parameters for uploadFilesIdGet operation in UploadFileApi.
 * @export
 * @interface UploadFileApiUploadFilesIdGetRequest
 */
export interface UploadFileApiUploadFilesIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof UploadFileApiUploadFilesIdGet
     */
    readonly id: string
}

/**
 * Request parameters for uploadPost operation in UploadFileApi.
 * @export
 * @interface UploadFileApiUploadPostRequest
 */
export interface UploadFileApiUploadPostRequest {
    /**
     * 
     * @type {Array<File>}
     * @memberof UploadFileApiUploadPost
     */
    readonly files: Array<File>

    /**
     * The folder where the file(s) will be uploaded to (only supported on strapi-provider-upload-aws-s3).
     * @type {string}
     * @memberof UploadFileApiUploadPost
     */
    readonly path?: string

    /**
     * The ID of the entry which the file(s) will be linked to
     * @type {string}
     * @memberof UploadFileApiUploadPost
     */
    readonly refId?: string

    /**
     * The unique ID (uid) of the model which the file(s) will be linked to (api::restaurant.restaurant).
     * @type {string}
     * @memberof UploadFileApiUploadPost
     */
    readonly ref?: string

    /**
     * The field of the entry which the file(s) will be precisely linked to.
     * @type {string}
     * @memberof UploadFileApiUploadPost
     */
    readonly field?: string
}

/**
 * Request parameters for uploadididPost operation in UploadFileApi.
 * @export
 * @interface UploadFileApiUploadididPostRequest
 */
export interface UploadFileApiUploadididPostRequest {
    /**
     * File id
     * @type {string}
     * @memberof UploadFileApiUploadididPost
     */
    readonly id: string

    /**
     * 
     * @type {UploadIdIdPostRequestFileInfo}
     * @memberof UploadFileApiUploadididPost
     */
    readonly fileInfo?: UploadIdIdPostRequestFileInfo

    /**
     * 
     * @type {File}
     * @memberof UploadFileApiUploadididPost
     */
    readonly files?: File
}

/**
 * UploadFileApi - object-oriented interface
 * @export
 * @class UploadFileApi
 * @extends {BaseAPI}
 */
export class UploadFileApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadFileApi
     */
    public uploadFilesGet(options?: RawAxiosRequestConfig) {
        return UploadFileApiFp(this.configuration).uploadFilesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UploadFileApiUploadFilesIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadFileApi
     */
    public uploadFilesIdDelete(requestParameters: UploadFileApiUploadFilesIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return UploadFileApiFp(this.configuration).uploadFilesIdDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UploadFileApiUploadFilesIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadFileApi
     */
    public uploadFilesIdGet(requestParameters: UploadFileApiUploadFilesIdGetRequest, options?: RawAxiosRequestConfig) {
        return UploadFileApiFp(this.configuration).uploadFilesIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload files
     * @summary 
     * @param {UploadFileApiUploadPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadFileApi
     */
    public uploadPost(requestParameters: UploadFileApiUploadPostRequest, options?: RawAxiosRequestConfig) {
        return UploadFileApiFp(this.configuration).uploadPost(requestParameters.files, requestParameters.path, requestParameters.refId, requestParameters.ref, requestParameters.field, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload file information
     * @summary 
     * @param {UploadFileApiUploadididPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadFileApi
     */
    public uploadididPost(requestParameters: UploadFileApiUploadididPostRequest, options?: RawAxiosRequestConfig) {
        return UploadFileApiFp(this.configuration).uploadididPost(requestParameters.id, requestParameters.fileInfo, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersPermissionsAuthApi - axios parameter creator
 * @export
 */
export const UsersPermissionsAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update user\'s own password
         * @param {AuthChangePasswordPostRequest} authChangePasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authChangePasswordPost: async (authChangePasswordPostRequest: AuthChangePasswordPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authChangePasswordPostRequest' is not null or undefined
            assertParamExists('authChangePasswordPost', 'authChangePasswordPostRequest', authChangePasswordPostRequest)
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authChangePasswordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirm user email
         * @param {string} [confirmation] confirmation token received by email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailConfirmationGet: async (confirmation?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/email-confirmation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (confirmation !== undefined) {
                localVarQueryParameter['confirmation'] = confirmation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send rest password email
         * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authForgotPasswordPost: async (authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authForgotPasswordPostRequest' is not null or undefined
            assertParamExists('authForgotPasswordPost', 'authForgotPasswordPostRequest', authForgotPasswordPostRequest)
            const localVarPath = `/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authForgotPasswordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a jwt token and user info
         * @summary Local login
         * @param {AuthLocalPostRequest} authLocalPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLocalPost: async (authLocalPostRequest: AuthLocalPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authLocalPostRequest' is not null or undefined
            assertParamExists('authLocalPost', 'authLocalPostRequest', authLocalPostRequest)
            const localVarPath = `/auth/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLocalPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a jwt token and user info
         * @summary Register a user
         * @param {AuthLocalRegisterPostRequest} authLocalRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLocalRegisterPost: async (authLocalRegisterPostRequest: AuthLocalRegisterPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authLocalRegisterPostRequest' is not null or undefined
            assertParamExists('authLocalRegisterPost', 'authLocalRegisterPostRequest', authLocalRegisterPostRequest)
            const localVarPath = `/auth/local/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLocalRegisterPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Default Callback from provider auth
         * @param {string} provider Provider name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProviderCallbackGet: async (provider: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('authProviderCallbackGet', 'provider', provider)
            const localVarPath = `/auth/{provider}/callback`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rest user password
         * @param {AuthResetPasswordPostRequest} authResetPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPasswordPost: async (authResetPasswordPostRequest: AuthResetPasswordPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authResetPasswordPostRequest' is not null or undefined
            assertParamExists('authResetPasswordPost', 'authResetPasswordPostRequest', authResetPasswordPostRequest)
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authResetPasswordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send confirmation email
         * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSendEmailConfirmationPost: async (authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authForgotPasswordPostRequest' is not null or undefined
            assertParamExists('authSendEmailConfirmationPost', 'authForgotPasswordPostRequest', authForgotPasswordPostRequest)
            const localVarPath = `/auth/send-email-confirmation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authForgotPasswordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects to provider login before being redirect to /auth/{provider}/callback
         * @summary Login with a provider
         * @param {string} provider Provider name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectProviderGet: async (provider: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('connectProviderGet', 'provider', provider)
            const localVarPath = `/connect/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersPermissionsAuthApi - functional programming interface
 * @export
 */
export const UsersPermissionsAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersPermissionsAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update user\'s own password
         * @param {AuthChangePasswordPostRequest} authChangePasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authChangePasswordPost(authChangePasswordPostRequest: AuthChangePasswordPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsUserRegistration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authChangePasswordPost(authChangePasswordPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsAuthApi.authChangePasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Confirm user email
         * @param {string} [confirmation] confirmation token received by email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authEmailConfirmationGet(confirmation?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Error>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authEmailConfirmationGet(confirmation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsAuthApi.authEmailConfirmationGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send rest password email
         * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authForgotPasswordPost(authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthForgotPasswordPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authForgotPasswordPost(authForgotPasswordPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsAuthApi.authForgotPasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a jwt token and user info
         * @summary Local login
         * @param {AuthLocalPostRequest} authLocalPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLocalPost(authLocalPostRequest: AuthLocalPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsUserRegistration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLocalPost(authLocalPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsAuthApi.authLocalPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a jwt token and user info
         * @summary Register a user
         * @param {AuthLocalRegisterPostRequest} authLocalRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLocalRegisterPost(authLocalRegisterPostRequest: AuthLocalRegisterPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsUserRegistration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLocalRegisterPost(authLocalRegisterPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsAuthApi.authLocalRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Default Callback from provider auth
         * @param {string} provider Provider name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authProviderCallbackGet(provider: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsUserRegistration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authProviderCallbackGet(provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsAuthApi.authProviderCallbackGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Rest user password
         * @param {AuthResetPasswordPostRequest} authResetPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authResetPasswordPost(authResetPasswordPostRequest: AuthResetPasswordPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsUserRegistration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authResetPasswordPost(authResetPasswordPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsAuthApi.authResetPasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send confirmation email
         * @param {AuthForgotPasswordPostRequest} authForgotPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSendEmailConfirmationPost(authForgotPasswordPostRequest: AuthForgotPasswordPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSendEmailConfirmationPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSendEmailConfirmationPost(authForgotPasswordPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsAuthApi.authSendEmailConfirmationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Redirects to provider login before being redirect to /auth/{provider}/callback
         * @summary Login with a provider
         * @param {string} provider Provider name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectProviderGet(provider: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Error>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectProviderGet(provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsAuthApi.connectProviderGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersPermissionsAuthApi - factory interface
 * @export
 */
export const UsersPermissionsAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersPermissionsAuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Update user\'s own password
         * @param {UsersPermissionsAuthApiAuthChangePasswordPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authChangePasswordPost(requestParameters: UsersPermissionsAuthApiAuthChangePasswordPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<UsersPermissionsUserRegistration> {
            return localVarFp.authChangePasswordPost(requestParameters.authChangePasswordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Confirm user email
         * @param {UsersPermissionsAuthApiAuthEmailConfirmationGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailConfirmationGet(requestParameters: UsersPermissionsAuthApiAuthEmailConfirmationGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Error> {
            return localVarFp.authEmailConfirmationGet(requestParameters.confirmation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send rest password email
         * @param {UsersPermissionsAuthApiAuthForgotPasswordPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authForgotPasswordPost(requestParameters: UsersPermissionsAuthApiAuthForgotPasswordPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthForgotPasswordPost200Response> {
            return localVarFp.authForgotPasswordPost(requestParameters.authForgotPasswordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a jwt token and user info
         * @summary Local login
         * @param {UsersPermissionsAuthApiAuthLocalPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLocalPost(requestParameters: UsersPermissionsAuthApiAuthLocalPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<UsersPermissionsUserRegistration> {
            return localVarFp.authLocalPost(requestParameters.authLocalPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a jwt token and user info
         * @summary Register a user
         * @param {UsersPermissionsAuthApiAuthLocalRegisterPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLocalRegisterPost(requestParameters: UsersPermissionsAuthApiAuthLocalRegisterPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<UsersPermissionsUserRegistration> {
            return localVarFp.authLocalRegisterPost(requestParameters.authLocalRegisterPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Default Callback from provider auth
         * @param {UsersPermissionsAuthApiAuthProviderCallbackGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProviderCallbackGet(requestParameters: UsersPermissionsAuthApiAuthProviderCallbackGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<UsersPermissionsUserRegistration> {
            return localVarFp.authProviderCallbackGet(requestParameters.provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rest user password
         * @param {UsersPermissionsAuthApiAuthResetPasswordPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPasswordPost(requestParameters: UsersPermissionsAuthApiAuthResetPasswordPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<UsersPermissionsUserRegistration> {
            return localVarFp.authResetPasswordPost(requestParameters.authResetPasswordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send confirmation email
         * @param {UsersPermissionsAuthApiAuthSendEmailConfirmationPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSendEmailConfirmationPost(requestParameters: UsersPermissionsAuthApiAuthSendEmailConfirmationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthSendEmailConfirmationPost200Response> {
            return localVarFp.authSendEmailConfirmationPost(requestParameters.authForgotPasswordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Redirects to provider login before being redirect to /auth/{provider}/callback
         * @summary Login with a provider
         * @param {UsersPermissionsAuthApiConnectProviderGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectProviderGet(requestParameters: UsersPermissionsAuthApiConnectProviderGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Error> {
            return localVarFp.connectProviderGet(requestParameters.provider, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authChangePasswordPost operation in UsersPermissionsAuthApi.
 * @export
 * @interface UsersPermissionsAuthApiAuthChangePasswordPostRequest
 */
export interface UsersPermissionsAuthApiAuthChangePasswordPostRequest {
    /**
     * 
     * @type {AuthChangePasswordPostRequest}
     * @memberof UsersPermissionsAuthApiAuthChangePasswordPost
     */
    readonly authChangePasswordPostRequest: AuthChangePasswordPostRequest
}

/**
 * Request parameters for authEmailConfirmationGet operation in UsersPermissionsAuthApi.
 * @export
 * @interface UsersPermissionsAuthApiAuthEmailConfirmationGetRequest
 */
export interface UsersPermissionsAuthApiAuthEmailConfirmationGetRequest {
    /**
     * confirmation token received by email
     * @type {string}
     * @memberof UsersPermissionsAuthApiAuthEmailConfirmationGet
     */
    readonly confirmation?: string
}

/**
 * Request parameters for authForgotPasswordPost operation in UsersPermissionsAuthApi.
 * @export
 * @interface UsersPermissionsAuthApiAuthForgotPasswordPostRequest
 */
export interface UsersPermissionsAuthApiAuthForgotPasswordPostRequest {
    /**
     * 
     * @type {AuthForgotPasswordPostRequest}
     * @memberof UsersPermissionsAuthApiAuthForgotPasswordPost
     */
    readonly authForgotPasswordPostRequest: AuthForgotPasswordPostRequest
}

/**
 * Request parameters for authLocalPost operation in UsersPermissionsAuthApi.
 * @export
 * @interface UsersPermissionsAuthApiAuthLocalPostRequest
 */
export interface UsersPermissionsAuthApiAuthLocalPostRequest {
    /**
     * 
     * @type {AuthLocalPostRequest}
     * @memberof UsersPermissionsAuthApiAuthLocalPost
     */
    readonly authLocalPostRequest: AuthLocalPostRequest
}

/**
 * Request parameters for authLocalRegisterPost operation in UsersPermissionsAuthApi.
 * @export
 * @interface UsersPermissionsAuthApiAuthLocalRegisterPostRequest
 */
export interface UsersPermissionsAuthApiAuthLocalRegisterPostRequest {
    /**
     * 
     * @type {AuthLocalRegisterPostRequest}
     * @memberof UsersPermissionsAuthApiAuthLocalRegisterPost
     */
    readonly authLocalRegisterPostRequest: AuthLocalRegisterPostRequest
}

/**
 * Request parameters for authProviderCallbackGet operation in UsersPermissionsAuthApi.
 * @export
 * @interface UsersPermissionsAuthApiAuthProviderCallbackGetRequest
 */
export interface UsersPermissionsAuthApiAuthProviderCallbackGetRequest {
    /**
     * Provider name
     * @type {string}
     * @memberof UsersPermissionsAuthApiAuthProviderCallbackGet
     */
    readonly provider: string
}

/**
 * Request parameters for authResetPasswordPost operation in UsersPermissionsAuthApi.
 * @export
 * @interface UsersPermissionsAuthApiAuthResetPasswordPostRequest
 */
export interface UsersPermissionsAuthApiAuthResetPasswordPostRequest {
    /**
     * 
     * @type {AuthResetPasswordPostRequest}
     * @memberof UsersPermissionsAuthApiAuthResetPasswordPost
     */
    readonly authResetPasswordPostRequest: AuthResetPasswordPostRequest
}

/**
 * Request parameters for authSendEmailConfirmationPost operation in UsersPermissionsAuthApi.
 * @export
 * @interface UsersPermissionsAuthApiAuthSendEmailConfirmationPostRequest
 */
export interface UsersPermissionsAuthApiAuthSendEmailConfirmationPostRequest {
    /**
     * 
     * @type {AuthForgotPasswordPostRequest}
     * @memberof UsersPermissionsAuthApiAuthSendEmailConfirmationPost
     */
    readonly authForgotPasswordPostRequest: AuthForgotPasswordPostRequest
}

/**
 * Request parameters for connectProviderGet operation in UsersPermissionsAuthApi.
 * @export
 * @interface UsersPermissionsAuthApiConnectProviderGetRequest
 */
export interface UsersPermissionsAuthApiConnectProviderGetRequest {
    /**
     * Provider name
     * @type {string}
     * @memberof UsersPermissionsAuthApiConnectProviderGet
     */
    readonly provider: string
}

/**
 * UsersPermissionsAuthApi - object-oriented interface
 * @export
 * @class UsersPermissionsAuthApi
 * @extends {BaseAPI}
 */
export class UsersPermissionsAuthApi extends BaseAPI {
    /**
     * 
     * @summary Update user\'s own password
     * @param {UsersPermissionsAuthApiAuthChangePasswordPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public authChangePasswordPost(requestParameters: UsersPermissionsAuthApiAuthChangePasswordPostRequest, options?: RawAxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).authChangePasswordPost(requestParameters.authChangePasswordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Confirm user email
     * @param {UsersPermissionsAuthApiAuthEmailConfirmationGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public authEmailConfirmationGet(requestParameters: UsersPermissionsAuthApiAuthEmailConfirmationGetRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).authEmailConfirmationGet(requestParameters.confirmation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send rest password email
     * @param {UsersPermissionsAuthApiAuthForgotPasswordPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public authForgotPasswordPost(requestParameters: UsersPermissionsAuthApiAuthForgotPasswordPostRequest, options?: RawAxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).authForgotPasswordPost(requestParameters.authForgotPasswordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a jwt token and user info
     * @summary Local login
     * @param {UsersPermissionsAuthApiAuthLocalPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public authLocalPost(requestParameters: UsersPermissionsAuthApiAuthLocalPostRequest, options?: RawAxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).authLocalPost(requestParameters.authLocalPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a jwt token and user info
     * @summary Register a user
     * @param {UsersPermissionsAuthApiAuthLocalRegisterPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public authLocalRegisterPost(requestParameters: UsersPermissionsAuthApiAuthLocalRegisterPostRequest, options?: RawAxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).authLocalRegisterPost(requestParameters.authLocalRegisterPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Default Callback from provider auth
     * @param {UsersPermissionsAuthApiAuthProviderCallbackGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public authProviderCallbackGet(requestParameters: UsersPermissionsAuthApiAuthProviderCallbackGetRequest, options?: RawAxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).authProviderCallbackGet(requestParameters.provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rest user password
     * @param {UsersPermissionsAuthApiAuthResetPasswordPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public authResetPasswordPost(requestParameters: UsersPermissionsAuthApiAuthResetPasswordPostRequest, options?: RawAxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).authResetPasswordPost(requestParameters.authResetPasswordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send confirmation email
     * @param {UsersPermissionsAuthApiAuthSendEmailConfirmationPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public authSendEmailConfirmationPost(requestParameters: UsersPermissionsAuthApiAuthSendEmailConfirmationPostRequest, options?: RawAxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).authSendEmailConfirmationPost(requestParameters.authForgotPasswordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Redirects to provider login before being redirect to /auth/{provider}/callback
     * @summary Login with a provider
     * @param {UsersPermissionsAuthApiConnectProviderGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsAuthApi
     */
    public connectProviderGet(requestParameters: UsersPermissionsAuthApiConnectProviderGetRequest, options?: RawAxiosRequestConfig) {
        return UsersPermissionsAuthApiFp(this.configuration).connectProviderGet(requestParameters.provider, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersPermissionsUsersRolesApi - axios parameter creator
 * @export
 */
export const UsersPermissionsUsersRolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCountGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} id user Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdDelete', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user
         * @param {string} id user Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user
         * @param {string} id user Id
         * @param {UsersPostRequest} usersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut: async (id: string, usersPostRequest: UsersPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdPut', 'id', id)
            // verify required parameter 'usersPostRequest' is not null or undefined
            assertParamExists('usersIdPut', 'usersPostRequest', usersPostRequest)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get authenticated user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get default generated permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsPermissionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users-permissions/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users-permissions/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a role
         * @param {string} id role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPermissionsRolesIdGet', 'id', id)
            const localVarPath = `/users-permissions/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a role
         * @param {UsersPermissionsRolesPostRequest} usersPermissionsRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesPost: async (usersPermissionsRolesPostRequest: UsersPermissionsRolesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersPermissionsRolesPostRequest' is not null or undefined
            assertParamExists('usersPermissionsRolesPost', 'usersPermissionsRolesPostRequest', usersPermissionsRolesPostRequest)
            const localVarPath = `/users-permissions/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersPermissionsRolesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a role
         * @param {string} role role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesRoleDelete: async (role: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('usersPermissionsRolesRoleDelete', 'role', role)
            const localVarPath = `/users-permissions/roles/{role}`
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a role
         * @param {string} role role Id
         * @param {UsersPermissionsRolesPostRequest} usersPermissionsRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesRolePut: async (role: string, usersPermissionsRolesPostRequest: UsersPermissionsRolesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('usersPermissionsRolesRolePut', 'role', role)
            // verify required parameter 'usersPermissionsRolesPostRequest' is not null or undefined
            assertParamExists('usersPermissionsRolesRolePut', 'usersPermissionsRolesPostRequest', usersPermissionsRolesPostRequest)
            const localVarPath = `/users-permissions/roles/{role}`
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersPermissionsRolesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a user
         * @param {UsersPostRequest} usersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (usersPostRequest: UsersPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersPostRequest' is not null or undefined
            assertParamExists('usersPost', 'usersPostRequest', usersPostRequest)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersPermissionsUsersRolesApi - functional programming interface
 * @export
 */
export const UsersPermissionsUsersRolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersPermissionsUsersRolesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCountGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCountGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsUsersRolesApi.usersCountGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get list of users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsersPermissionsUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsUsersRolesApi.usersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} id user Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsUsersRolesApi.usersIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user
         * @param {string} id user Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsUsersRolesApi.usersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a user
         * @param {string} id user Id
         * @param {UsersPostRequest} usersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdPut(id: string, usersPostRequest: UsersPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdPut(id, usersPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsUsersRolesApi.usersIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get authenticated user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsUsersRolesApi.usersMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get default generated permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsPermissionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsPermissionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsPermissionsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsUsersRolesApi.usersPermissionsPermissionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsRolesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsRolesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsRolesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsUsersRolesApi.usersPermissionsRolesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a role
         * @param {string} id role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsRolesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPermissionsRolesIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsRolesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsUsersRolesApi.usersPermissionsRolesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a role
         * @param {UsersPermissionsRolesPostRequest} usersPermissionsRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsRolesPost(usersPermissionsRolesPostRequest: UsersPermissionsRolesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthForgotPasswordPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsRolesPost(usersPermissionsRolesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsUsersRolesApi.usersPermissionsRolesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a role
         * @param {string} role role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsRolesRoleDelete(role: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthForgotPasswordPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsRolesRoleDelete(role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsUsersRolesApi.usersPermissionsRolesRoleDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a role
         * @param {string} role role Id
         * @param {UsersPermissionsRolesPostRequest} usersPermissionsRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsRolesRolePut(role: string, usersPermissionsRolesPostRequest: UsersPermissionsRolesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthForgotPasswordPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsRolesRolePut(role, usersPermissionsRolesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsUsersRolesApi.usersPermissionsRolesRolePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a user
         * @param {UsersPostRequest} usersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(usersPostRequest: UsersPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(usersPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersPermissionsUsersRolesApi.usersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersPermissionsUsersRolesApi - factory interface
 * @export
 */
export const UsersPermissionsUsersRolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersPermissionsUsersRolesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCountGet(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.usersCountGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<UsersPermissionsUser>> {
            return localVarFp.usersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user
         * @param {UsersPermissionsUsersRolesApiUsersIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete(requestParameters: UsersPermissionsUsersRolesApiUsersIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<UsersPermissionsUser> {
            return localVarFp.usersIdDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user
         * @param {UsersPermissionsUsersRolesApiUsersIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(requestParameters: UsersPermissionsUsersRolesApiUsersIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<UsersPermissionsUser> {
            return localVarFp.usersIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user
         * @param {UsersPermissionsUsersRolesApiUsersIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut(requestParameters: UsersPermissionsUsersRolesApiUsersIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<UsersPost201Response> {
            return localVarFp.usersIdPut(requestParameters.id, requestParameters.usersPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get authenticated user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options?: RawAxiosRequestConfig): AxiosPromise<UsersPermissionsUser> {
            return localVarFp.usersMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get default generated permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsPermissionsGet(options?: RawAxiosRequestConfig): AxiosPromise<UsersPermissionsPermissionsGet200Response> {
            return localVarFp.usersPermissionsPermissionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesGet(options?: RawAxiosRequestConfig): AxiosPromise<UsersPermissionsRolesGet200Response> {
            return localVarFp.usersPermissionsRolesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a role
         * @param {UsersPermissionsUsersRolesApiUsersPermissionsRolesIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesIdGet(requestParameters: UsersPermissionsUsersRolesApiUsersPermissionsRolesIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<UsersPermissionsRolesIdGet200Response> {
            return localVarFp.usersPermissionsRolesIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a role
         * @param {UsersPermissionsUsersRolesApiUsersPermissionsRolesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesPost(requestParameters: UsersPermissionsUsersRolesApiUsersPermissionsRolesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthForgotPasswordPost200Response> {
            return localVarFp.usersPermissionsRolesPost(requestParameters.usersPermissionsRolesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a role
         * @param {UsersPermissionsUsersRolesApiUsersPermissionsRolesRoleDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesRoleDelete(requestParameters: UsersPermissionsUsersRolesApiUsersPermissionsRolesRoleDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthForgotPasswordPost200Response> {
            return localVarFp.usersPermissionsRolesRoleDelete(requestParameters.role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a role
         * @param {UsersPermissionsUsersRolesApiUsersPermissionsRolesRolePutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRolesRolePut(requestParameters: UsersPermissionsUsersRolesApiUsersPermissionsRolesRolePutRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthForgotPasswordPost200Response> {
            return localVarFp.usersPermissionsRolesRolePut(requestParameters.role, requestParameters.usersPermissionsRolesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a user
         * @param {UsersPermissionsUsersRolesApiUsersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(requestParameters: UsersPermissionsUsersRolesApiUsersPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<UsersPost201Response> {
            return localVarFp.usersPost(requestParameters.usersPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for usersIdDelete operation in UsersPermissionsUsersRolesApi.
 * @export
 * @interface UsersPermissionsUsersRolesApiUsersIdDeleteRequest
 */
export interface UsersPermissionsUsersRolesApiUsersIdDeleteRequest {
    /**
     * user Id
     * @type {string}
     * @memberof UsersPermissionsUsersRolesApiUsersIdDelete
     */
    readonly id: string
}

/**
 * Request parameters for usersIdGet operation in UsersPermissionsUsersRolesApi.
 * @export
 * @interface UsersPermissionsUsersRolesApiUsersIdGetRequest
 */
export interface UsersPermissionsUsersRolesApiUsersIdGetRequest {
    /**
     * user Id
     * @type {string}
     * @memberof UsersPermissionsUsersRolesApiUsersIdGet
     */
    readonly id: string
}

/**
 * Request parameters for usersIdPut operation in UsersPermissionsUsersRolesApi.
 * @export
 * @interface UsersPermissionsUsersRolesApiUsersIdPutRequest
 */
export interface UsersPermissionsUsersRolesApiUsersIdPutRequest {
    /**
     * user Id
     * @type {string}
     * @memberof UsersPermissionsUsersRolesApiUsersIdPut
     */
    readonly id: string

    /**
     * 
     * @type {UsersPostRequest}
     * @memberof UsersPermissionsUsersRolesApiUsersIdPut
     */
    readonly usersPostRequest: UsersPostRequest
}

/**
 * Request parameters for usersPermissionsRolesIdGet operation in UsersPermissionsUsersRolesApi.
 * @export
 * @interface UsersPermissionsUsersRolesApiUsersPermissionsRolesIdGetRequest
 */
export interface UsersPermissionsUsersRolesApiUsersPermissionsRolesIdGetRequest {
    /**
     * role Id
     * @type {string}
     * @memberof UsersPermissionsUsersRolesApiUsersPermissionsRolesIdGet
     */
    readonly id: string
}

/**
 * Request parameters for usersPermissionsRolesPost operation in UsersPermissionsUsersRolesApi.
 * @export
 * @interface UsersPermissionsUsersRolesApiUsersPermissionsRolesPostRequest
 */
export interface UsersPermissionsUsersRolesApiUsersPermissionsRolesPostRequest {
    /**
     * 
     * @type {UsersPermissionsRolesPostRequest}
     * @memberof UsersPermissionsUsersRolesApiUsersPermissionsRolesPost
     */
    readonly usersPermissionsRolesPostRequest: UsersPermissionsRolesPostRequest
}

/**
 * Request parameters for usersPermissionsRolesRoleDelete operation in UsersPermissionsUsersRolesApi.
 * @export
 * @interface UsersPermissionsUsersRolesApiUsersPermissionsRolesRoleDeleteRequest
 */
export interface UsersPermissionsUsersRolesApiUsersPermissionsRolesRoleDeleteRequest {
    /**
     * role Id
     * @type {string}
     * @memberof UsersPermissionsUsersRolesApiUsersPermissionsRolesRoleDelete
     */
    readonly role: string
}

/**
 * Request parameters for usersPermissionsRolesRolePut operation in UsersPermissionsUsersRolesApi.
 * @export
 * @interface UsersPermissionsUsersRolesApiUsersPermissionsRolesRolePutRequest
 */
export interface UsersPermissionsUsersRolesApiUsersPermissionsRolesRolePutRequest {
    /**
     * role Id
     * @type {string}
     * @memberof UsersPermissionsUsersRolesApiUsersPermissionsRolesRolePut
     */
    readonly role: string

    /**
     * 
     * @type {UsersPermissionsRolesPostRequest}
     * @memberof UsersPermissionsUsersRolesApiUsersPermissionsRolesRolePut
     */
    readonly usersPermissionsRolesPostRequest: UsersPermissionsRolesPostRequest
}

/**
 * Request parameters for usersPost operation in UsersPermissionsUsersRolesApi.
 * @export
 * @interface UsersPermissionsUsersRolesApiUsersPostRequest
 */
export interface UsersPermissionsUsersRolesApiUsersPostRequest {
    /**
     * 
     * @type {UsersPostRequest}
     * @memberof UsersPermissionsUsersRolesApiUsersPost
     */
    readonly usersPostRequest: UsersPostRequest
}

/**
 * UsersPermissionsUsersRolesApi - object-oriented interface
 * @export
 * @class UsersPermissionsUsersRolesApi
 * @extends {BaseAPI}
 */
export class UsersPermissionsUsersRolesApi extends BaseAPI {
    /**
     * 
     * @summary Get user count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersCountGet(options?: RawAxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersCountGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersGet(options?: RawAxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user
     * @param {UsersPermissionsUsersRolesApiUsersIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersIdDelete(requestParameters: UsersPermissionsUsersRolesApiUsersIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersIdDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user
     * @param {UsersPermissionsUsersRolesApiUsersIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersIdGet(requestParameters: UsersPermissionsUsersRolesApiUsersIdGetRequest, options?: RawAxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user
     * @param {UsersPermissionsUsersRolesApiUsersIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersIdPut(requestParameters: UsersPermissionsUsersRolesApiUsersIdPutRequest, options?: RawAxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersIdPut(requestParameters.id, requestParameters.usersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get authenticated user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersMeGet(options?: RawAxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get default generated permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersPermissionsPermissionsGet(options?: RawAxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersPermissionsPermissionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersPermissionsRolesGet(options?: RawAxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersPermissionsRolesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a role
     * @param {UsersPermissionsUsersRolesApiUsersPermissionsRolesIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersPermissionsRolesIdGet(requestParameters: UsersPermissionsUsersRolesApiUsersPermissionsRolesIdGetRequest, options?: RawAxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersPermissionsRolesIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a role
     * @param {UsersPermissionsUsersRolesApiUsersPermissionsRolesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersPermissionsRolesPost(requestParameters: UsersPermissionsUsersRolesApiUsersPermissionsRolesPostRequest, options?: RawAxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersPermissionsRolesPost(requestParameters.usersPermissionsRolesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a role
     * @param {UsersPermissionsUsersRolesApiUsersPermissionsRolesRoleDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersPermissionsRolesRoleDelete(requestParameters: UsersPermissionsUsersRolesApiUsersPermissionsRolesRoleDeleteRequest, options?: RawAxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersPermissionsRolesRoleDelete(requestParameters.role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a role
     * @param {UsersPermissionsUsersRolesApiUsersPermissionsRolesRolePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersPermissionsRolesRolePut(requestParameters: UsersPermissionsUsersRolesApiUsersPermissionsRolesRolePutRequest, options?: RawAxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersPermissionsRolesRolePut(requestParameters.role, requestParameters.usersPermissionsRolesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a user
     * @param {UsersPermissionsUsersRolesApiUsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersPermissionsUsersRolesApi
     */
    public usersPost(requestParameters: UsersPermissionsUsersRolesApiUsersPostRequest, options?: RawAxiosRequestConfig) {
        return UsersPermissionsUsersRolesApiFp(this.configuration).usersPost(requestParameters.usersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



